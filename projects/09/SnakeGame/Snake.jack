// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/09/Square/Square.jack

/** Implements a graphical square. */
class Snake {

    // field int x, y; // screen location of the square's top-left corner

    field Array body; // snake body, 1 dim array, [x1,y1, x2,y2, ...]
    field int maxSLen; // make snake length
    field int sLen; // current snake length
    field int sqSize; // square size
    field int i;
    field int boundX;
    field int boundY;

    field int headIdx;
    field int headX;
    field int headY;

    field int tailIdx;

    field int temp;


    /** Constructs a snake head with a given location and size. */
    /** sx: start x */
    /** sx: start y */
    /** squareSize: square size */
    /** snakeMaxLength: max snake length to make array */
    constructor Snake new(int sx, int sy, int squareSize, int snakeMaxLength) {
        let maxSLen = snakeMaxLength;
        let sqSize = squareSize;
        let body = Array.new(maxSLen*2);
        let boundX = (512 / sqSize) - 2;
        let boundY = (256 / sqSize) - 2;

        let sLen = 1;
        let headIdx = 0;
        let tailIdx = 0;
        let headX = sx;
        let headY = sy;
        let body[0] = sx;
        let body[1] = sy;

        let temp = 0;

        do drawSnake();


        return this;
    }

    method int getSnakeLength(){ return sLen;}
    method int getSnakeHeadX(){ return headX;}
    method int getSnakeHeadY(){ return headY;}
    method Array getSnakeBody(){ return body;}


    /** Disposes this square. */
    method void dispose() {
        do Memory.deAlloc(this);
        return;
    }

    /** Draws the square on the screen. */
    method void drawSnake() {
        do Screen.setColor(true);

        let i = 0;
        while ( i < sLen) {
            do Screen.drawRectangle(body[i*2]*sqSize, body[i*2+1]*sqSize,
                                    body[i*2]*sqSize + sqSize, body[i*2+1]*sqSize + sqSize);
            let i = i+1;
        }
        return;
    }

    /** erases the square from the screen. */
    method void erase() {
        do Screen.setcolor(false);
        let i = 0;
        while ( i < sLen) {
            do Screen.drawRectangle(body[i*2], body[i*2+1],
                                    body[i*2] + sqSize, body[i*2+1] + sqSize);
            let i = i+1;
        }
        return;
    }

    method void drawHead(){
        do Screen.setColor(true);
        do Screen.drawRectangle((headX*sqSize), (headY*sqSize),
                                (headX*sqSize)+ sqSize, (headY*sqSize) + sqSize);
        return;
    }

    method void eraseTail(){
        do Sys.wait(50);  // delays the next movement
        do Screen.setColor(false);
        do Screen.drawRectangle(body[tailIdx*2] * sqSize, body[tailIdx*2+1] *sqSize,
                                body[tailIdx*2]*sqSize + sqSize, body[tailIdx*2+1] * sqSize + sqSize);
        return;
    }

    method void setNextHeadIdx(){
        if (headIdx < (sLen-1)){
            let headIdx = headIdx + 1;
        } else {
            let headIdx = 0;
        }
        return ;
    }
    method void setNextTailIdx(){
        if (tailIdx < (sLen-1)){
            let tailIdx = tailIdx + 1;
        } else {
            let tailIdx = 0;
        }
        return ;
    }

    /** Moves the square up by 2 pixels. */
    method void moveUp() {
        if (headY > 0){
            do eraseTail(); // erase current tail
            do setNextTailIdx(); // set new tail

            do setNextHeadIdx(); // set new head idx
            let headY = headY - 1; // update head
            let body[headIdx*2] = headX; // add new head to the body
            let body[headIdx*2+1] = headY;

            do drawHead(); // draw new head
        }

        return;
    }


    /** Moves the square down by 2 pixels. */
    method void moveDown() {
        if (headY < boundY){
            do eraseTail(); // erase current tail
            do setNextTailIdx(); // set new tail
            do setNextHeadIdx(); // set new head idx
            let headY = headY + 1; // update head info
            let body[headIdx*2] = headX;
            let body[headIdx*2+1] = headY;
            do drawHead(); // draw new head
        }
        return;
    }

    method void moveLeft() {
        if (headX > 0){
            do eraseTail(); // erase current tail
            do setNextTailIdx(); // set new tail
            do setNextHeadIdx(); // set new head idx
            let headX = headX - 1; // update head info
            let body[headIdx*2] = headX;
            let body[headIdx*2+1] = headY;
            do drawHead(); // draw new head
        }
        return;
    }

    method void moveRight() {

        if (headX < boundX){
            do eraseTail(); // erase current tail
            do setNextTailIdx(); // set new tail

            do setNextHeadIdx(); // set new head idx
            // let headX = headX;

            let headX = headX + 1; // update head info
            let body[headIdx*2] = headX;
            let body[headIdx*2+1] = headY;

            do drawHead(); // draw new head
        }

        return;
    }

    method void addDown() {

        // headIdx change
        // tailIdx not change
        // add x,y to body
        // sLen change
        // draw the rect
        if (headY < boundY){

            // move tailIdx when headIdx was right before tailIdx so tailIdx has been pushed
            if (tailIdx - 1= headIdx){
                do eraseTail(); // erase current tail
                let tailIdx = tailIdx + 1;
            }
            // push all points from the current headIdx
            // first, move the last element and second last .. until headIdx+2
            let i = sLen;
            while (i > headIdx+1){
                let body[i*2] = body[(i-1)*2];
                let body[i*2+1] = body[(i-1)*2+1];
                let i = i - 1;
            }
            let headIdx = headIdx+1;
            let headY = headY + 1; // update head info
            let body[headIdx*2] = headX;
            let body[headIdx*2+1] = headY;
            let sLen = sLen + 1;


            do drawHead(); // draw new head
        }

        return;
    }

}
