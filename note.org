
* course overview

we are going to work on part#1 in Coursea.
#+DOWNLOADED: screenshot @ 2020-12-24 23:13:32
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/course_overview/2020-12-24_23-13-32_screenshot.png]]

Going to learn from bottom-up

* The Hack Computer

#+DOWNLOADED: screenshot @ 2020-12-24 23:15:39
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/The_Hack_Computer/2020-12-24_23-15-39_screenshot.png]]


#+DOWNLOADED: screenshot @ 2020-12-24 23:18:14
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/The_Hack_Computer/2020-12-24_23-18-14_screenshot.png]]

#+DOWNLOADED: screenshot @ 2020-12-24 23:18:29
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/The_Hack_Computer/2020-12-24_23-18-29_screenshot.png]]

* Project#0 overview
[[https://www.nand2tetris.org/software][Software | nand2tetris]]
#+DOWNLOADED: screenshot @ 2020-12-24 23:25:59
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/The_Hack_Computer/2020-12-24_23-25-59_screenshot.png]]

#+DOWNLOADED: screenshot @ 2020-12-24 23:26:22
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/The_Hack_Computer/2020-12-24_23-26-22_screenshot.png]]

* Module#1 - Boolean functions and gate logic
** boolean logic
#+DOWNLOADED: screenshot @ 2020-12-25 00:22:42
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/The_Hack_Computer/2020-12-25_00-22-42_screenshot.png]]

** boolean functions synthesis
Just with ANDs and NOTs, we can construct any Boolean function

#+DOWNLOADED: screenshot @ 2020-12-25 00:20:50
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/The_Hack_Computer/2020-12-25_00-20-50_screenshot.png]]


and you can make AND and NOT gate with NAND gate

#+DOWNLOADED: screenshot @ 2020-12-25 00:19:42
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/The_Hack_Computer/2020-12-25_00-19-42_screenshot.png]]

** Logic gates

*** Elementary logic gates: NAND

#+DOWNLOADED: screenshot @ 2020-12-25 00:27:51
#+ATTR_ORG: :width 400
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/The_Hack_Computer/2020-12-25_00-27-51_screenshot.png]]

*** Elementary logic gates: AND, OR, NOT

#+DOWNLOADED: screenshot @ 2020-12-25 00:28:32
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/The_Hack_Computer/2020-12-25_00-28-32_screenshot.png]]

*** Composites gates / Gate Interface & Gate Implementation

#+DOWNLOADED: screenshot @ 2020-12-25 00:29:21
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/The_Hack_Computer/2020-12-25_00-29-21_screenshot.png]]

*** Circuit Implementation

#+DOWNLOADED: screenshot @ 2020-12-25 00:31:27
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/The_Hack_Computer/2020-12-25_00-31-27_screenshot.png]]


#+DOWNLOADED: screenshot @ 2020-12-25 00:31:58
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/The_Hack_Computer/2020-12-25_00-31-58_screenshot.png]]

** Hardware description language (HDL)
*** Design: from requirements to interface

#+DOWNLOADED: screenshot @ 2020-12-25 00:36:58
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/The_Hack_Computer/2020-12-25_00-36-58_screenshot.png]]

*** Design: from gate diagram to HDL

#+DOWNLOADED: screenshot @ 2020-12-25 00:43:21
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/The_Hack_Computer/2020-12-25_00-43-21_screenshot.png]]

The interface is unique and implementation varies.
As someone who use this chips(like Xor, And) we only need to know interface and for someone who design these chips need to know implementation of these chips.

*** HDL: some comments

#+DOWNLOADED: screenshot @ 2020-12-25 00:47:28
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/The_Hack_Computer/2020-12-25_00-47-28_screenshot.png]]


#+DOWNLOADED: screenshot @ 2020-12-25 00:48:47
#+ATTR_ORG: :width 400
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/The_Hack_Computer/2020-12-25_00-48-47_screenshot.png]]

** Hardware simulation
*** Hardware simulation in a nutshell

#+DOWNLOADED: screenshot @ 2020-12-25 00:56:20
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/The_Hack_Computer/2020-12-25_00-56-20_screenshot.png]]

*** Interactive simulation

*** Script-based simulation
#+DOWNLOADED: screenshot @ 2020-12-25 01:06:21
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/The_Hack_Computer/2020-12-25_01-06-21_screenshot.png]]

#+DOWNLOADED: screenshot @ 2020-12-25 01:07:48
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/The_Hack_Computer/2020-12-25_01-07-48_screenshot.png]]

#+DOWNLOADED: screenshot @ 2020-12-25 01:08:17
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/The_Hack_Computer/2020-12-25_01-08-17_screenshot.png]]

** Multi-bit buses

** Project#1 overview

#+DOWNLOADED: screenshot @ 2020-12-25 16:26:37
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/The_Hack_Computer/2020-12-25_16-26-37_screenshot.png]]

#+DOWNLOADED: screenshot @ 2020-12-25 16:27:22
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/The_Hack_Computer/2020-12-25_16-27-22_screenshot.png]]

*** Multiplexor

#+DOWNLOADED: screenshot @ 2020-12-25 16:41:36
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/The_Hack_Computer/2020-12-25_16-41-36_screenshot.png]]

*** Example: using mux logic to build a programmable gate

#+DOWNLOADED: screenshot @ 2020-12-25 16:43:29
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/The_Hack_Computer/2020-12-25_16-43-29_screenshot.png]]

*** Multiplexor implementation

#+DOWNLOADED: screenshot @ 2020-12-25 16:47:41
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/The_Hack_Computer/2020-12-25_16-47-41_screenshot.png]]

*** Demultiplexor

#+DOWNLOADED: screenshot @ 2020-12-25 16:48:08
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[file:/home/jinho/Dropbox/org/pictures/The_Hack_Computer/2020-12-25_16-48-08_screenshot.png]]

*** Example: Mutliplexing / demultiplexing in communication networks

#+DOWNLOADED: screenshot @ 2020-12-25 16:59:09
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/The_Hack_Computer/2020-12-25_16-59-09_screenshot.png]]

*** And16

#+DOWNLOADED: screenshot @ 2020-12-25 17:01:28
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/The_Hack_Computer/2020-12-25_17-01-28_screenshot.png]]

*** Mux4Way16

#+DOWNLOADED: screenshot @ 2020-12-25 17:02:17
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/The_Hack_Computer/2020-12-25_17-02-17_screenshot.png]]

*** Chip building materials(using Xor as an example)

#+DOWNLOADED: screenshot @ 2020-12-25 17:04:30
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/The_Hack_Computer/2020-12-25_17-04-30_screenshot.png]]

* Module#2 - Boolean Arithmetic and the ALU Roadmap
In a nutshell: Using the chipset that we've built in the previous module, we will now proceed to build a ~family of adders~ -- chips designed to add numbers. We will then take a big step forward and build an ~Arithmetic Logic Unit~. The ~ALU~, which is designed to perform a ~whole set of arithmetic and logical operations~, is the ~computer's calculating brain.~ Later in the course we will use this ALU as the centerpiece chip from which we will build the computer's Central Processing Unit, or CPU. Since all these chips operate on binary numbers (0's and 1's), we will start this module with a general overview of binary arithmetic, and only then delve into building the ALU.

Key concepts: Binary numbers, binary addition, the two's complement method, half-adders, full-adders, n-bit adders, counters, Arithmetic Logic Unit (ALU), combinational logic.
** binary numbers

** negative numbers - 2's complement

#+DOWNLOADED: screenshot @ 2020-12-25 21:22:13
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/The_Hack_Computer/2020-12-25_21-22-13_screenshot.png]]

#+DOWNLOADED: screenshot @ 2020-12-25 21:29:15
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/The_Hack_Computer/2020-12-25_21-29-15_screenshot.png]]

4bit -5 can be represented 1011_(2)

make 5 (0101)_(2) and change the bits(1010)_(2) and add 1 then
you get 1011_(2)

** Arithmetic Logic Unit(ALU)

#+DOWNLOADED: screenshot @ 2020-12-26 01:17:42
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#2_-_Boolean_Arithmetic_and_the_ALU_Roadmap/2020-12-26_01-17-42_screenshot.png]]

*** The Hack ALU

#+DOWNLOADED: screenshot @ 2020-12-26 01:18:43
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#2_-_Boolean_Arithmetic_and_the_ALU_Roadmap/2020-12-26_01-18-43_screenshot.png]]

#+DOWNLOADED: screenshot @ 2020-12-26 01:19:50
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#2_-_Boolean_Arithmetic_and_the_ALU_Roadmap/2020-12-26_01-19-50_screenshot.png]]

*** The Hack ALU in action: compute y-x

#+DOWNLOADED: screenshot @ 2020-12-26 13:58:34
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#2_-_Boolean_Arithmetic_and_the_ALU_Roadmap/2020-12-26_13-58-34_screenshot.png]]

#+DOWNLOADED: screenshot @ 2020-12-26 17:17:05
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#2_-_Boolean_Arithmetic_and_the_ALU_Roadmap/2020-12-26_17-17-05_screenshot.png]]

*** The Hack ALU in action: compute x & y

#+DOWNLOADED: screenshot @ 2020-12-26 14:02:52
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#2_-_Boolean_Arithmetic_and_the_ALU_Roadmap/2020-12-26_14-02-52_screenshot.png]]

*** Half adder

#+DOWNLOADED: screenshot @ 2020-12-26 17:25:20
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#2_-_Boolean_Arithmetic_and_the_ALU_Roadmap/2020-12-26_17-25-20_screenshot.png]]

*** Full adder

#+DOWNLOADED: screenshot @ 2020-12-26 17:25:38
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#2_-_Boolean_Arithmetic_and_the_ALU_Roadmap/2020-12-26_17-25-38_screenshot.png]]

*** 16-bit adder

#+DOWNLOADED: screenshot @ 2020-12-26 17:25:54
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#2_-_Boolean_Arithmetic_and_the_ALU_Roadmap/2020-12-26_17-25-54_screenshot.png]]

*** 16-bit incrementor

#+DOWNLOADED: screenshot @ 2020-12-26 17:26:40
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#2_-_Boolean_Arithmetic_and_the_ALU_Roadmap/2020-12-26_17-26-40_screenshot.png]]

*** ALU

#+DOWNLOADED: screenshot @ 2020-12-26 17:27:17
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#2_-_Boolean_Arithmetic_and_the_ALU_Roadmap/2020-12-26_17-27-17_screenshot.png]]

* Module#3 - Memory
In a nutshell: Having built the computer's ~ALU~, this module we turn to ~building the computer's main memory unit, also known as Random Access Memory, or RAM.~ This will be done gradually, going ~bottom-up from elementary flip-flop gates to one-bit registers to n-bit registers to a family of RAM chips.~ Unlike the computer's processing chips, which are based on combinational logic, the computer's memory logic requires a clock-based sequential logic. We will start with an overview of this theoretical background, and then move on to build our memory chipset.

Key concepts: combinational vs sequential logic, clocks and cycles, flip-flops, registers, RAM units, counters.
** Sequential logic

#+DOWNLOADED: screenshot @ 2020-12-26 21:55:01
#+ATTR_ORG: :width 400
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#3_-_Memory/2020-12-26_21-55-01_screenshot.png]]

*** The clock

#+DOWNLOADED: screenshot @ 2020-12-26 22:00:01
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#3_-_Memory/2020-12-26_22-00-01_screenshot.png]]

**** ignore gray areas

#+DOWNLOADED: screenshot @ 2020-12-26 22:05:25
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#3_-_Memory/2020-12-26_22-05-25_screenshot.png]]

care about end of the gray area because we know it's gone by the end
of the clock cycle.  Then we can think about time in integer steps.

The after the gray area(where the system is stabilized) is the area that we will care about.

*** Combinatorial logic vs sequential logic


#+DOWNLOADED: screenshot @ 2020-12-26 22:11:52
#+ATTR_ORG: :width 450
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#3_-_Memory/2020-12-26_22-11-52_screenshot.png]]

#+DOWNLOADED: screenshot @ 2020-12-26 22:09:09
#+ATTR_ORG: :width 450
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#3_-_Memory/2020-12-26_22-09-09_screenshot.png]]

#+DOWNLOADED: screenshot @ 2020-12-26 22:10:59
#+ATTR_ORG: :width 450
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#3_-_Memory/2020-12-26_22-10-59_screenshot.png]]

** Flip flops

#+DOWNLOADED: screenshot @ 2020-12-26 22:20:08
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#3_-_Memory/2020-12-26_22-20-08_screenshot.png]]

#+DOWNLOADED: screenshot @ 2020-12-26 22:21:49
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#3_-_Memory/2020-12-26_22-21-49_screenshot.png]]

*** Implementation of the D flip flop

#+DOWNLOADED: screenshot @ 2020-12-26 22:23:50
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#3_-_Memory/2020-12-26_22-23-50_screenshot.png]]

*** Sequential logic implementation

#+DOWNLOADED: screenshot @ 2020-12-26 22:25:25
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#3_-_Memory/2020-12-26_22-25-25_screenshot.png]]

*** Remembering for ever: 1-bit register

#+DOWNLOADED: screenshot @ 2020-12-26 22:26:21
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#3_-_Memory/2020-12-26_22-26-21_screenshot.png]]

*** 1-Bit register

#+DOWNLOADED: screenshot @ 2020-12-26 22:29:07
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#3_-_Memory/2020-12-26_22-29-07_screenshot.png]]

How can we pipe the value that we remember so it will keep on being remembered until we ask to change it?
*** First "Bit" implementation attempt
#+DOWNLOADED: screenshot @ 2020-12-26 22:33:33
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#3_-_Memory/2020-12-26_22-33-33_screenshot.png]]

#+DOWNLOADED: screenshot @ 2020-12-26 22:33:53
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#3_-_Memory/2020-12-26_22-33-53_screenshot.png]]
*** Working "Bit" implementation

#+DOWNLOADED: screenshot @ 2020-12-26 22:34:16
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#3_-_Memory/2020-12-26_22-34-16_screenshot.png]]
*** 1-Bit register (with Mux)
Mux select "in" when load==1 and select the previous state of DFF when load==0

#+DOWNLOADED: screenshot @ 2020-12-26 22:35:52
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#3_-_Memory/2020-12-26_22-35-52_screenshot.png]]

#+DOWNLOADED: screenshot @ 2020-12-26 22:37:21
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#3_-_Memory/2020-12-26_22-37-21_screenshot.png]]

#+DOWNLOADED: screenshot @ 2020-12-26 22:39:13
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#3_-_Memory/2020-12-26_22-39-13_screenshot.png]]

So basically, whenever load is being pulled to high, we load the input from in and keep it until the next time that a load is asked.
** Memory units
*** Von Neumann Architecture

#+DOWNLOADED: screenshot @ 2020-12-26 22:55:31
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#3_-_Memory/2020-12-26_22-55-31_screenshot.png]]

*** Memory

#+DOWNLOADED: screenshot @ 2020-12-26 22:57:08
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#3_-_Memory/2020-12-26_22-57-08_screenshot.png]]

this course we are going to learn about
#+DOWNLOADED: screenshot @ 2020-12-26 23:01:07
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#3_-_Memory/2020-12-26_23-01-07_screenshot.png]]

*** The most basic memory element: ~Register~

#+DOWNLOADED: screenshot @ 2020-12-26 23:03:07
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#3_-_Memory/2020-12-26_23-03-07_screenshot.png]]

Another thing that I'd like to say is that I'm going to use a lot the term register's ~state~. And in fact, this term was introduced in the previous unit as well. ~State is the value which is currently stored~, quote unquote, inside the register. To say it more precisely, this is the value which is currently being expressed by the internal circuits of, the register. This is a more, I think, accurate description of what's going on. It creates an ~illusion of, of storage~

*** Register / read logic
#+DOWNLOADED: screenshot @ 2020-12-26 23:09:25
#+ATTR_ORG: :width 450
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#3_-_Memory/2020-12-26_23-09-25_screenshot.png]]

*** Register / write logic

#+DOWNLOADED: screenshot @ 2020-12-26 23:10:50
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#3_-_Memory/2020-12-26_23-10-50_screenshot.png]]

*** Register chip in action

#+DOWNLOADED: screenshot @ 2020-12-26 23:22:47
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#3_-_Memory/2020-12-26_23-22-47_screenshot.png]]

*** RAM Unit

#+DOWNLOADED: screenshot @ 2020-12-26 23:25:26
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#3_-_Memory/2020-12-26_23-25-26_screenshot.png]]

triangle in the diagram means it's ~sequential~ chip.

*** RAM / Read logic

#+DOWNLOADED: screenshot @ 2020-12-26 23:29:06
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#3_-_Memory/2020-12-26_23-29-06_screenshot.png]]

*** RAM / write logic

#+DOWNLOADED: screenshot @ 2020-12-26 23:28:53
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#3_-_Memory/2020-12-26_23-28-53_screenshot.png]]

*** RAM chip in action

#+DOWNLOADED: screenshot @ 2020-12-26 23:31:24
#+ATTR_ORG: :width 800
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#3_-_Memory/2020-12-26_23-31-24_screenshot.png]]

#+DOWNLOADED: screenshot @ 2020-12-26 23:32:04
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#3_-_Memory/2020-12-26_23-32-04_screenshot.png]]

change 4th(address[3]) register value(to 12, which is in[16]) (need to set load 1)

*** A family of 16-bit RAM chips

#+DOWNLOADED: screenshot @ 2020-12-26 23:41:55
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#3_-_Memory/2020-12-26_23-41-55_screenshot.png]]

 Irrespective of the size of this chip, irre, irrespective of whether it has 8 registers or 8 million registers, I can select every register from this chip and apply an operation on it in exactly the same axis time which is truly remarkable. All I have to do is ~enter the address of this register into the address input and boom, this register is going to be selected and all the other registers are going to be ignored.~ Okay now there is no boom in reality, I'm doing it for dramatic effect. But actually it's quite dramatic because once again if I now want to select the register number of 5,000, all I have to do is enter 5,000 and boom, this register becomes irrelevant and register number 5,000 becomes active and, and it, it it kind of opens up for business. And it doesn't matter if I have 8 million registers or 8 billion registers. I have this basic ability to select at random any register in this configuration and either read it or write it in the same access time. So this is truly a remarkable functionality and later on in this week, you will actually build this functionality using HDL.

** Counters
*** where counters come to play

#+DOWNLOADED: screenshot @ 2020-12-27 01:56:29
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#3_-_Memory/2020-12-27_01-56-29_screenshot.png]]

*** Counter abstraction

#+DOWNLOADED: screenshot @ 2020-12-27 01:58:08
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#3_-_Memory/2020-12-27_01-58-08_screenshot.png]]

** Project#3 overview

#+DOWNLOADED: screenshot @ 2020-12-27 02:05:24
#+ATTR_ORG: :width 400
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#3_-_Memory/2020-12-27_02-05-24_screenshot.png]]

*** 1-bit register

#+DOWNLOADED: screenshot @ 2020-12-27 02:05:56
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#3_-_Memory/2020-12-27_02-05-56_screenshot.png]]

*** 16-bit register

#+DOWNLOADED: screenshot @ 2020-12-27 02:06:12
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#3_-_Memory/2020-12-27_02-06-12_screenshot.png]]

*** 8-Register RAM
#+DOWNLOADED: screenshot @ 2020-12-27 02:07:02
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#3_-_Memory/2020-12-27_02-07-02_screenshot.png]]

*** RAM8, RAM64, .. RAM16k

#+DOWNLOADED: screenshot @ 2020-12-27 02:08:48
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#3_-_Memory/2020-12-27_02-08-48_screenshot.png]]

*** PC(Program Counter)

#+DOWNLOADED: screenshot @ 2020-12-27 02:09:47
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#3_-_Memory/2020-12-27_02-09-47_screenshot.png]]

* Module#4 - Machine Language
In a nutshell: A critically important aspect of building a new computer system is ~designing the low-level machine language~, or ~instruction set~, with which the computer can be instructed to do various things. As it turns out, this can be done before the computer itself is actually built. For example, we can write a Java program that emulates the yet-to-be-built computer, and then use it to emulate the execution of programs written in the new machine language. Such experiments can give us a good appreciation of the bare bone "look and feel" of the new computer, and lead to decisions that may well change and improve both the hardware and the language designs. Taking a similar approach, in this module we assume that the Hack computer and machine language have been built, and write some low-level programs using the Hack machine language. We will then use a supplied CPU Emulator (a computer program) to test and execute our programs. This experience will give you a ~taste of low-level programming, as well as a solid hands-on overview of the Hack computer platform.~

Key concepts: op codes, mnemonics, binary machine language, symbolic machine language, assembly, low-level arithmetic, logical, addressing, branching, and I/O commands, CPU emulation, low-level programming.

** Machine Languages: Overview

#+DOWNLOADED: screenshot @ 2020-12-29 14:08:19
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_14-08-19_screenshot.png]]

*** Stored program computer

#+DOWNLOADED: screenshot @ 2020-12-29 14:15:00
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_14-15-00_screenshot.png]]

*** Machine languages

#+DOWNLOADED: screenshot @ 2020-12-29 14:15:47
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_14-15-47_screenshot.png]]

**** Machine languages: Operations

#+DOWNLOADED: screenshot @ 2020-12-29 14:16:43
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_14-16-43_screenshot.png]]

Our program is going to be, is going to be composed of, of a sequence of instructions. What exactly does the ~instruction~ tell the computer to do? That's one element.
**** Machine languages: Program counter

#+DOWNLOADED: screenshot @ 2020-12-29 14:17:01
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_14-17-01_screenshot.png]]

The other element is, how do we know ~which instruction to perform~ at any given stage and time? Suppose we are now in instruction 74, it makes sense that the next instruction we will do is 75. But sometimes, we will ~need to change the order~ maybe to do some kind of loops or to do things conditionally. That's the second kind of element that we need to be able, so, that ~software needs to be able to control the operation of the hardware~.


#+DOWNLOADED: screenshot @ 2020-12-29 14:19:30
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_14-19-30_screenshot.png]]

The third element which is really important, is if we're going to have to tell the hardware what to operate on. Even if the hardware knows it needs now to add two numbers. We have to tell it, the software has to tell the hardware, ~how exactly, where exactly will it get these two values~ that it's going to, that it needs to add and where should it put the result.

*** Compilation

#+DOWNLOADED: screenshot @ 2020-12-29 14:20:47
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_14-20-47_screenshot.png]]

*** Mnemonics

#+DOWNLOADED: screenshot @ 2020-12-29 14:46:29
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_14-46-29_screenshot.png]]

*** Symbols

#+DOWNLOADED: screenshot @ 2020-12-29 14:48:36
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_14-48-36_screenshot.png]]

** Machine Languages: Elements


#+DOWNLOADED: screenshot @ 2020-12-29 14:51:08
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_14-51-08_screenshot.png]]

*** Machine operations

#+DOWNLOADED: screenshot @ 2020-12-29 14:54:24
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_14-54-24_screenshot.png]]

*** Memory Hierarchy

#+DOWNLOADED: screenshot @ 2020-12-29 14:56:50
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_14-56-50_screenshot.png]]

~Problem~:
And that's going to be wasteful in terms of the instruction. If I just want to say oh, ~add the last two numbers~, I'm, can't, won't be able to just do that because I will ~have to specify two very large addresses in order to tell the hardware what to operate on~.

The second element, which is closely related, is the fact that just accessing a value from a large memory takes relatively large, a large amount of time. Com, compared to the state of the speed of the CPU itself, of the arithmetic operations themselves. So the way to handle these two things, the way to give us good control over what type of a, what, what type of data are we working on. Without requiring all these costs of specifying the large address and getting the information from a far away place if you wish, in terms of time, the basic solution was whats called a ~memory hierarchy~.

~Solution~:
And this was already figured out by when he built the first computer. The basic idea is ~instead of having just one large block of memory, we're going to have a whole sequence of memories that are getting bigger and bigger.~

The smallest memories are going to be very easy to access. First of all, because ~we don't have to specify large address space because there are only going to be a very few of them.~ Second of all, because ~there are only very few of them, we can actually get information from them very quickly~.

And then, there is going to be slightly ~larger memories~, usually called ~cache~, and even larger memories, sometimes called the big, the main memory. And maybe even, even larger memories that are going to sit on disk.

~At each time we get farther away from the arithmetic unit itself, our memory be, gets bigger.~ Accessing it becomes harder borth, both in terms of giving a larger, a wider address. And in terms of the time we need to wait until we get the value. But we have more information there. The ways that the different levels of the memory hierarchy are handled differs according to the different levels. But, what we're going to discuss now is the way that registers, the smallest, the smallest memory that usually resides really inside the CPU, and how we handle that. So eh, almost every CPU has a few, very small amount of memory registers that are located really inside the CPU. Their type and functionality's really part of the machine language. And the main point is that since there are so few of them, everything then requires very few bits, and getting the information of them is extremely quickly. They are built from the fastest technology available and it's, they are already inside the CPU, so there is no delay in getting in, any information from there.

*** Registers

#+DOWNLOADED: screenshot @ 2020-12-29 15:58:29
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_15-58-29_screenshot.png]]

*** Addressing modes

#+DOWNLOADED: screenshot @ 2020-12-29 16:02:38
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_16-02-38_screenshot.png]]

*** Input/Output

#+DOWNLOADED: screenshot @ 2020-12-29 16:03:45
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_16-03-45_screenshot.png]]

*** Machine Languages: Flow Control

#+DOWNLOADED: screenshot @ 2020-12-29 16:04:18
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_16-04-18_screenshot.png]]

#+DOWNLOADED: screenshot @ 2020-12-29 16:08:13
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_16-08-13_screenshot.png]]

** The Hack Computer and Machine Language
*** Hardware
#+DOWNLOADED: screenshot @ 2020-12-29 16:45:54
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_16-45-54_screenshot.png]]

*** software

#+DOWNLOADED: screenshot @ 2020-12-29 16:47:07
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_16-47-07_screenshot.png]]

*** Control

#+DOWNLOADED: screenshot @ 2020-12-29 16:50:15
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_16-50-15_screenshot.png]]

So we do have a ~reset button~ and here is how I cause this computer to do something useful for me. I write the program, the program is a set of 16 bit numbers. I take these uh,16 bit numbers and somehow put them into the ROM. We'll discuss later, how we actually do it then ~I press the reset button. And once I do this the program starts running.~ That's, that's the basic sort of user instructions of how to to cause this computer to do something useful. Now, I have no idea what this, what the computer will do it all depends on the program, you know. But hopefully the computer will start sounding some music or showing a video clip or compute the average of a million numbers or something like this. It all depends on what is written in the program.

*** Registers

#+DOWNLOADED: screenshot @ 2020-12-29 17:54:42
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_17-54-42_screenshot.png]]

First of all, there's the ~D register~ which ~holds a 16 bite value which represents a piece of data~. Then there's the ~A register~ which ~holds also a 16 bit value which represents either a data value or an address~. We'll talk about this later on. And finally, there is something called the selected ~memory register~ which is denoted by the ~letter M~. So it doesn't matter if I have 2 billion memory registers. At any given point of time, ~only one of them is selected and I can basically ignore all the other registers.~ They, they're irrelevant for what I currently do, ~I want to focus only on the currently selected register and I call this register M.~ You know, the, this is just a convention that we use in the specification of the hack machine language.

A : Address register, pointing memory register's address
D : data register, you can store data here
M : memory register, changing depends on address register(A, @)

*** The A-instruction

#+DOWNLOADED: screenshot @ 2020-12-29 18:14:01
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_18-14-01_screenshot.png]]

*** The C-instruction

#+DOWNLOADED: screenshot @ 2020-12-29 18:19:25
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_18-19-25_screenshot.png]]

**** JEQ

#+DOWNLOADED: screenshot @ 2020-12-29 18:22:37
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_18-22-37_screenshot.png]]

**** Example
#+DOWNLOADED: screenshot @ 2020-12-29 18:32:15
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_18-32-15_screenshot.png]]

** Hack language specification
*** Hack computer: software

#+DOWNLOADED: screenshot @ 2020-12-29 18:36:18
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_18-36-18_screenshot.png]]

*** The hack machine language

#+DOWNLOADED: screenshot @ 2020-12-29 18:39:36
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_18-39-36_screenshot.png]]

*** The A-instruction: Symbolic and binary syntax

#+DOWNLOADED: screenshot @ 2020-12-29 18:40:15
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_18-40-15_screenshot.png]]

For example, @ 21. So, here's the same instruction in, in its binary flavor. We ~begin with a special code zero~, which ~tells the computer that this is an A instruction.~

the first zero is something called, an ~op code~, an ~operation code~.

*** The C-instruction: Symbolic and binary syntax
dest, comp, jump
#+DOWNLOADED: screenshot @ 2020-12-29 20:00:55
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_20-00-55_screenshot.png]]
** Input/output
*** Hack computer platform

#+DOWNLOADED: screenshot @ 2020-12-29 20:08:01
#+ATTR_ORG: :width 400
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_20-08-01_screenshot.png]]

#+DOWNLOADED: screenshot @ 2020-12-29 20:09:55
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_20-09-55_screenshot.png]]

*** Hack computer platform: Output

#+DOWNLOADED: screenshot @ 2020-12-29 20:24:20
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_20-24-20_screenshot.png]]

*** Screen memory map

#+DOWNLOADED: screenshot @ 2020-12-29 20:43:33
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_20-43-33_screenshot.png]]
(left image: one row = 16(bit) * 32(lines) = 512 bits => display height)

So, we'll do some of this today and we'll do some more fancy input/output operations, some much more fancy operations in the second part of this course, as I explained as I explained earlier.

All right. So let's delve into the the screen memory map. Now, this is how we are used to think about display units. But as far as the hack computer is concerned, the display unit is the following obstruction. It's a ~table, or a matrix, consisting of 256 rows and 512 columns.~ And in each intersection of a, a row and a column, we have what is known as a ~pixel~. This is a black and white screen, so we can either turn the pixel on or we can turn it off. This is the physical display on it that the hack computer assumes. Now how do we control it? Well, as I just explained, we have something called a memory map. ~And the memory map is a sequence of 16-bit values~. ~Every one of these values is sometimes called a word~. So we have altogether, ~8k, 16-bit words.~ Why do we have 8k, 16-bit words? Because it turns out that ~8k times 16 gives something like 13,000 and something~, and this is the number of pixels that we have on the physical display unit. So, for every pixel on the physical display unit, we have a bit that represents this pixel in the screen memory map. And if I want to turn on this pixel, I put one in this bit. If I want to turn it off, I put zero in this bit.

So, in order to understand and, and control these bits judiciously, I have to come up with some ~mapping that describes exactly which bit corresponds to which pixel~.

Now this is a little but involved because on the right-hand side, I have a two-dimensional obstruction. And on the left-hand side, I have a one-dimensional obstruction, and I somehow have to connect the two. So how do we do it? Well, first of all, you should notice, and I'd like to re-emphasize the fact that when we access memory, ~we can only retrieve 16 bits in one chunk~. You know, we cannot access individual bits. If I want to access an individual bit, I have to figure out, first of all, ~in which word this bit resides~, so to speak.

And then I have to retrieve the entire word, do something to this value. And, you know, manipulate this particular bit and then I have to take this value and put it back, write it back into memory. So the read/write operations are always 16-bit operations. So I take the 16-bit out, manipulate something and put it back. All right? So what is the mapping? Well, here it is. ~The first 32 words in the in the memory map.~ Correspond to the first row in the display on it. Okay? So the first pixel that we see here and actually you can see it in the picture. We see that the picture begins with the four black pixels and indeed, we see four ones at the top of the memory. Then we have zero, one, zero, one. White, black, white, black and so on and so forth. Okay? So that's row zero, then we have row one, all the way down to row 255. Okay. So this is the first mapping that we have to to bear in mind. Now suppose that I want to manipulate a certain pixel on the screen and pixels on the screen are characterized by a row and a column. How do I map this row-column pair on the right register in the memory map? Well, here is how I do it. Well, first of all, I multiply row by 32 and then I compute column divided by 16. And this by the way is integer division. Namely, I throw away the remainder of the division. So for example, if column equals 18, then 18 divided by 16 is 1. So, I take the result of this integer, integer division. I add it up to 32 times row and this gives me the address of the register that they have to manipulate in the respective memory map. Now notice the word screen. Well, what does screen means here? Well, in the hack architecture and in this course, we are going to implement the screen memory map using a chip called Screen. So we're going to have an 8k chip called Screen, which behaves exactly as a memory unit. You know, we can, you can retrieve data from it, you can write data into it and this chip will, will serve as our memory map. However, when we build the overall computer, this chip is going to be part of the data memory. So the data memory or the RAM will consist of several chips and the screen will be one of them. You know, that's exactly how we described it before. We said that the memory map is part of the data memory. But notice that once you take this Screen chip and put it in a larger memory context, the base address of the memory map changes. So, if I access the Screen chip, I use the address that you see here. But if I access the overall RAM, I have to take this relative address and add to it the base address of the memory of the memory map in in the overall memory, which happens to be 16384. So this is just a technical detail. You know, if you want to write to the screen using the screen chip directly, use the first meth, the first algebraic expression. And if you want to if you are told that the Screen is part of a larger memory, you have to add up. The the base address. All right. So we have this 16-bit word and ~then we want to manipulate a particular bit inside it, which bit is it?~ Well it turns out that this bit is the ~column modular 16~. It's the remainder which remains after we divide column by 16. So we get the number, which is between zero and fifteen, we manipulate this bit, we, we turn it to zero or to one. We take the resulting value and we write it back into the RAM. Okay? That's the, if we won't do it, we won't achieve anything. Right? We have to somehow write it back into the memory map and in the next refresh, refresh cycle. What we just did is going to change the pixel in the in the outside display. I guess that some of you are kind of shocked at how much work it takes to to turn on, on and on, on or off one, one pixel, but that's it. That's, that's the reality. You know, if you work in a very low level in the level of bits that's what you have to do in order to control the screen. Now, I didn't work out all the algebra. You know, this is something that you can do on your own. It's it will take a few minutes if you want. But you can just, you know, take a example. Let's say that you want to change bit the bit in the fourth row and in column number 55. You know, workout the numbers and convince yourself that you are going to access the right bit in the memory.

#+DOWNLOADED: screenshot @ 2020-12-29 20:45:15
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_20-45-15_screenshot.png]]

*** Handling screen output in the hack platform

#+DOWNLOADED: screenshot @ 2020-12-29 21:02:32
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_21-02-32_screenshot.png]]

#+DOWNLOADED: screenshot @ 2020-12-29 21:03:11
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_21-03-11_screenshot.png]]

*** Hack Computer platform: Input
**** Keyboard

#+DOWNLOADED: screenshot @ 2020-12-29 21:06:02
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_21-06-02_screenshot.png]]

#+DOWNLOADED: screenshot @ 2020-12-29 21:07:13
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_21-07-13_screenshot.png]]

#+DOWNLOADED: screenshot @ 2020-12-29 21:07:33
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_21-07-33_screenshot.png]]

#+DOWNLOADED: screenshot @ 2020-12-29 21:20:25
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_21-20-25_screenshot.png]]
**** The hack character set

#+DOWNLOADED: screenshot @ 2020-12-29 21:17:46
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_21-17-46_screenshot.png]]


Those of you familiar with the notion of Unicode or ASCII can make the connection between these notions and in what we do here.
It's essentially the very same very same idea. And by the way, when you don't touch the keyboard, when, when nothing when the keyboard is idle, the number that we see in the memory map is 0. So, that's how we can tell if a keyboard is actually being used. The memory map once again, is this 16-bit register. And, if you want to check if which key is currently pressed, all we have to do is probe the contents of the keyboard chip.

In the Hack computer we probe the contents of RAM in address 24576. Because, this is where the keyboard memory map, memory map happens to reside.

**** Handling the keyboard input in the hack platform

#+DOWNLOADED: screenshot @ 2020-12-29 21:26:49
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_21-26-49_screenshot.png]]

** Hack programming, part #1 - working with registers and memory
*** Lecture schedule
current unit == 4.6
#+DOWNLOADED: screenshot @ 2020-12-29 21:32:56
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_21-32-56_screenshot.png]]

*** Hack assembly instructions
#+DOWNLOADED: screenshot @ 2020-12-29 21:29:36
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_21-29-36_screenshot.png]]

*** Hack assembler

#+DOWNLOADED: screenshot @ 2020-12-29 21:30:43
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_21-30-43_screenshot.png]]

*** CPU Emulator

#+DOWNLOADED: screenshot @ 2020-12-29 21:31:44
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_21-31-44_screenshot.png]]

*** Working with registers and memory

#+DOWNLOADED: screenshot @ 2020-12-29 21:34:28
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_21-34-28_screenshot.png]]

#+DOWNLOADED: screenshot @ 2020-12-29 21:37:53
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_21-37-53_screenshot.png]]

**** Example

#+DOWNLOADED: screenshot @ 2020-12-29 21:38:58
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_21-38-58_screenshot.png]]

*** Hack program example: add two numbers

#+DOWNLOADED: screenshot @ 2020-12-29 21:55:45
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_21-55-45_screenshot.png]]

**** demo

#+DOWNLOADED: screenshot @ 2020-12-29 21:58:53
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_21-58-53_screenshot.png]]

#+DOWNLOADED: screenshot @ 2020-12-29 21:59:49
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_21-59-49_screenshot.png]]

problem: program doesn't end

*** How to terminate a program properly?

#+DOWNLOADED: screenshot @ 2020-12-29 22:01:16
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_22-01-16_screenshot.png]]

NOP attack: Null instructions or Null Opcodes

If I were a bad hacker and I would have seen this pattern of execution I would say, well maybe I can ~write some malicious program and put it somewhere downstream in this memory.~ And then I would let the user run his or her program naively. The user will happily run his program. The program will actually do What it's supposed to do. But then, ~unknowingly, the computer will continue executing and then, boom.~ My program will go to work and will start to do some bad things like deleting random files on the user's computer. So, what can we do In order to avoid this potential program. By the way this particular attack is called the ~NOP slide(sled)~ and NOP stands for Null instructions or Null Opcodes and what we have here in instructions six onward are Null instructions and a bed hacker can use this instructions to slide the flow of control to an area of the memory that he controls and then something bad can happen. What can we do to avert this problem? And in general, ~what can we do to terminate the program properly?~ well one thing that you have to understand is ~that computers never stand still.~ They always do something even when you don't touch the keyboard. There are many processes running in the background. ~So, in the hacked computer, because we don't want the computer to do something crazy.~ We might as well cause the computer to do something that we control. ~So what we can do is we can end the program with an infinite loop.~ We can end two commands like @six and then in seven jumped to six so we have once again @six and then in seven jumped to six, jump six, jump six and so on. ~And we have this infinite loop and everything is under control because this is something that we intended our program to do.~ So, as the best practice advice, we recommend that you end everyone of your program with the infinite loop.

#+DOWNLOADED: screenshot @ 2020-12-29 23:00:43
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_23-00-43_screenshot.png]]

*** Built-in symbols


#+DOWNLOADED: screenshot @ 2020-12-29 23:07:20
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_23-07-20_screenshot.png]]


I'd like to say a few things about another feature of the language that we haven't yet discussed and by saying this I'm basically going to complete the specification of the hack machine language. The language features several built in symbols and here they are. First of all, we have a ~set of sixteen so called virtual registers~. Or to say it more accurately, we have a ~set of sixteen labels that we use as if they represented Virtual registers.~ And these labels ~range from R0 to R15~.

And the construct is such that when the assembler or the translator sees a label like R3, it will replace it with a number 3. That's all. So, you might ask yourself, why do we need this fancy labels? Well, here's an example where this labels can come to play. This is a very simple piece of code in which we set RAM 5 to 15. Now let's read carefully what is going on here.

Problem:
  In the first pair of instructions, ~we use the A register as a data register.~ We put the number fifteen into A, and move it into D. In the second pair of instructions, we do something remarkably different. We use to @five command. ~To address the memory, to select memory register number five~ and then we do M equals D. So there's something troubling about this code. ~First of all we do two very different things but we use exactly the same syntax, at number.~

#+DOWNLOADED: screenshot @ 2020-12-29 23:08:25
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_23-08-25_screenshot.png]]

** Hack programming, part #2 - Branching, variables, iterations
*** Branching

#+DOWNLOADED: screenshot @ 2020-12-29 23:27:37
#+ATTR_ORG: :width 400
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_23-27-37_screenshot.png]]

In this program, we want to look at the certain data value, and decide, or determine whether, or not this value is, is positive, or, or not. So, we decide as a matter of convention that the value will reside in RAM(0). So, you know, the user of this program has a responsibility of putting a value in RAM(0), and then when the user press execute, the program spins its wheels, and at the end of the execution the program will put in R1, in RAM(1) either the value 1 if RAM(0) is positive, or the value 0 elsewhere. ~So, this is a typical if else, and unfortunately, we don't have a way to express this thing that directly in, in low level programming,~ low level program, programming is much more spartan and minimal. And therefore, we have to work hard to make this happen. In particular, here is some code that I have wrote, written to accomplish this,

this operation, it's probably not the only way to do it, but it works.

#+DOWNLOADED: screenshot @ 2020-12-29 23:28:56
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_23-28-56_screenshot.png]]

**** Labels

#+DOWNLOADED: screenshot @ 2020-12-29 23:33:05
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_23-33-05_screenshot.png]]

label declarations: (POSTIVE), (END)
reference: @POSITIVE, @END

***** example

#+DOWNLOADED: screenshot @ 2020-12-29 23:39:29
#+ATTR_ORG: :width 400
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_23-39-29_screenshot.png]]

don't understand
isn't it should be NOR_EQUAL_TO_0 ?

*** Variables

#+DOWNLOADED: screenshot @ 2020-12-29 23:52:13
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_23-52-13_screenshot.png]]

**** relocatable program

#+DOWNLOADED: screenshot @ 2020-12-29 23:53:35
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_23-53-35_screenshot.png]]

 This program has another very nice virtue, which is more subtle and this is the fact that this program is what is known as ~relocatable code~. I can take this program and load it into memory not necessarily to address zero. ~I can put it anywhere I want in memory as long as I remember what is the base address that they used for this program.~ This is extremely important, because as you know, when you work with your personal computer, you typically have several programs executing at the same time. So you can imply from this that several programs are loaded into your main memory. And once we write this program carefully using symbolic references, we don't have to worry about where they will be located in memory. We can write something called loader that takes care of this technical detail. So symbolic programs are good.
*** Iterative processing

#+DOWNLOADED: screenshot @ 2020-12-29 23:58:22
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-29_23-58-22_screenshot.png]]

#+DOWNLOADED: screenshot @ 2020-12-30 00:02:50
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-30_00-02-50_screenshot.png]]
1. first Pseudo code
2. understand and make sure how code actually works
3. then translate to assembly from Pseudo code

And then I recommend that you debug your pseudo code and convince yourself that the pseudo code actually works. And once you convince yourself that it works, you can reduce the task of reading, of writing the machine code to that of simply translating from pseudo code to machine language. And you see, this is much easier to do. You know, you look at the pseudo command like n equals R0, and you write a set of instructions in machine language that do the same.


#+DOWNLOADED: screenshot @ 2020-12-30 00:06:53
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-30_00-06-53_screenshot.png]]

And the second way to verify that the code works, which is no less important, is once your program is written, ~you have to simulate it or we recommend that you simulate it on paper~, using some sort of what is known as a ~trace table~.

**** Best practice
1. Design the program using pseudo code
2. Write the program in assembly language
3. Test the program(on paper) using a variable-value trace table

** Hack programming, part #3 - Pointers, Input/output
*** example - assign first ten registers -1
**** init
#+DOWNLOADED: screenshot @ 2020-12-30 07:30:56
#+ATTR_ORG: :width 300
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-30_07-30-56_screenshot.png]]

**** loop

#+DOWNLOADED: screenshot @ 2020-12-30 07:32:04
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-30_07-32-04_screenshot.png]]

A : Address register, pointing memory register's address
D : data register, you can store data here
M : memory register, changing depends on address register(A, @)
*** Input/output

#+DOWNLOADED: screenshot @ 2020-12-30 07:42:48
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-30_07-42-48_screenshot.png]]

**** I/O programming example: drawing a rectangle

#+DOWNLOADED: screenshot @ 2020-12-30 07:44:23
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-30_07-44-23_screenshot.png]]
***** I/O programming example: demo
***** I/O programming example: pseudo code

#+DOWNLOADED: screenshot @ 2020-12-30 07:59:51
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-30_07-59-51_screenshot.png]]

We use the first 32 words in the map to represent an entire row of 512 pixels. And then we use the next 32 words to represent the next row and so on and so forth. 32 times 16 gives you 512 pixels which gives you one row in the physical display, you alternate, and because we're interested only in the first 16 pixels in each row, we can safely jump from the current word to the current word plus 32 or the index of the current word plus 32.

#+DOWNLOADED: screenshot @ 2020-12-30 08:01:47
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-30_08-01-47_screenshot.png]]

#+begin_src asm
@LOOP
0;JMP

// go to @LOOP no matter what, so that means, there has to be a jump inside the loop to terminate the loop

// which is D;JGT

@END
D;JGT
// go to @END if D (= i-n) > 0
#+end_src

**** Handling the keyboard

#+DOWNLOADED: screenshot @ 2020-12-30 08:13:23
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-30_08-13-23_screenshot.png]]

** Project#4 overview

#+DOWNLOADED: screenshot @ 2020-12-30 08:18:50
#+ATTR_ORG: :width 300
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-30_08-18-50_screenshot.png]]

*** Mult: a program performing R2 = R0 * R1

#+DOWNLOADED: screenshot @ 2020-12-30 08:19:49
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-30_08-19-49_screenshot.png]]

use loop, addition, and subtraction

*** Fill: a simple interactive program

#+DOWNLOADED: screenshot @ 2020-12-30 08:22:58
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-30_08-22-58_screenshot.png]]

listen to the keyboard(any key) and blacken the screen when any key is pressed.


#+DOWNLOADED: screenshot @ 2020-12-30 08:24:41
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-30_08-24-41_screenshot.png]]

*** Program development process

#+DOWNLOADED: screenshot @ 2020-12-30 08:27:02
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-30_08-27-02_screenshot.png]]

*** Best practice


#+DOWNLOADED: screenshot @ 2020-12-30 08:29:40
#+ATTR_ORG: :width 350
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#4_-_Machine_Language/2020-12-30_08-29-40_screenshot.png]]

** perspectives

*** difference between typical machine languages and Hack machine languages

Well the Hack machine language is very simple because it is designed to operate on top of a very simple hardware platform. And we built this computer in purpose as a very simple architecture. Because we want to, to be able to actually build it in, you know, in the a space of a six weeks course and therefore the computer is very simple, but it ~sufficiently powerful to to offer almost everything that you need for reasons that I will explain in just a minute. So, typical machine languages are much more rich than the Hack instruction set~. They offer ~more commands more instruction types more data types, like floating point and more operations~, like for example, ~multiplication and division~. And yet, as I said before, there’s no need to worry because all these fancy things that other languages offer can be delivered at the software level at a higher level of obstruction and that’s exactly what we’ll do in the second part of this course.

* Module#5 - Computer Architecture
In a nutshell: Let's recap the last four modules: we've built some elementary logic gates (module 1), and then used them to build an ALU (module 2) and a RAM (module 3). We then played with low-level programming (module 4), assuming that the overall computer is actually available. In this module we ~assemble all these building blocks into a general-purpose 16-bit computer called Hack.~ We will start by building the Hack Central Processing Unit (CPU), and we will then integrate the CPU with the RAM, creating a full-blown computer system capable of executing programs written in the Hack machine language.

Key concepts: Von Neumann and Harvard architectures, the stored program concept, fetch-execute cycle, data bus, instruction bus, CPU, computer design.

** Von Neumann Architecture

#+DOWNLOADED: screenshot @ 2020-12-30 12:35:04
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_12-35-04_screenshot.png]]

 The most amazing thing was that ~one computer is able to run any kind of program,~ any kind of software that it is supposed to be able to get instruction from the software and then just execute it. So we get a single machine that is very flexible and can do everything. That idea was called the ~universal Turing machine~, in the theoretical world. And the architecture that ~actually implements it is called the von Neumann architecture~.
*** Stored program computer

#+DOWNLOADED: screenshot @ 2020-12-30 12:35:24
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_12-35-24_screenshot.png]]

*** Information flows

#+DOWNLOADED: screenshot @ 2020-12-30 12:37:05
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_12-37-05_screenshot.png]]

three different types of informations are there
1. control
2. address
3. data

**** The arithmetic logic unit

#+DOWNLOADED: screenshot @ 2020-12-30 12:38:42
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_12-38-42_screenshot.png]]

**** Control

#+DOWNLOADED: screenshot @ 2020-12-30 12:39:34
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_12-39-34_screenshot.png]]

**** Address registers

#+DOWNLOADED: screenshot @ 2020-12-30 12:41:39
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_12-41-39_screenshot.png]]

**** Memory

#+DOWNLOADED: screenshot @ 2020-12-30 12:45:32
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_12-45-32_screenshot.png]]

***** data memory

***** program memory

#+DOWNLOADED: screenshot @ 2020-12-30 12:49:20
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_12-49-20_screenshot.png]]

put the ~address of the next program instruction~ into the program memory because this is where we're taking our program instructions. We ~need to be able to put an address into the program memory address~, and then ~get the instructions from there~. Now the instructions that we get from the program memory, both may have data in it. For example, it may have numbers that we need to add, and so on. But, also it's an important thing, is the ~program actually tells, the program instruction tells the rest of the system what to do~. So we need to be able to actually take information from the data output of the program memory. And ~feed it into the control bus~.
** The fetch-execute cycle
*** fetching
- Put the location of the next instruction into the "address"of the program memory
- get the instruction code itself by reading the memory contents at that location

#+DOWNLOADED: screenshot @ 2020-12-30 15:58:52
#+ATTR_ORG: :width 400
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_15-58-52_screenshot.png]]

*** execute

#+DOWNLOADED: screenshot @ 2020-12-30 15:59:10
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_15-59-10_screenshot.png]]

**** executing an instruction

#+DOWNLOADED: screenshot @ 2020-12-30 16:01:25
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_16-01-25_screenshot.png]]

**** fetch-execute clash

#+DOWNLOADED: screenshot @ 2020-12-30 16:03:42
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_16-03-42_screenshot.png]]

**** Solution: Multiplex

#+DOWNLOADED: screenshot @ 2020-12-30 16:04:46
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_16-04-46_screenshot.png]]

#+DOWNLOADED: screenshot @ 2020-12-30 16:05:33
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_16-05-33_screenshot.png]]

**** Simpler Solution: Harvard Architecture

#+DOWNLOADED: screenshot @ 2020-12-30 16:06:02
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_16-06-02_screenshot.png]]

** Central Processing Unit(CPU)
*** The Hack CPU: Abstraction

#+DOWNLOADED: screenshot @ 2020-12-30 16:13:52
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_16-13-52_screenshot.png]]
*** Hack CPU interface

#+DOWNLOADED: screenshot @ 2020-12-30 16:16:19
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_16-16-19_screenshot.png]]

*** Hack CPU Implementation

#+DOWNLOADED: screenshot @ 2020-12-30 16:17:46
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_16-17-46_screenshot.png]]

c = control bits

**** Instruction handling

#+DOWNLOADED: screenshot @ 2020-12-30 16:20:09
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_16-20-09_screenshot.png]]

***** A instruction
#+DOWNLOADED: screenshot @ 2020-12-30 16:22:04
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_16-22-04_screenshot.png]]

op-code : 0 = A-instruction

***** C instruction

#+DOWNLOADED: screenshot @ 2020-12-30 16:23:48
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_16-23-48_screenshot.png]]

**** ALU operation

#+DOWNLOADED: screenshot @ 2020-12-30 16:25:22
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_16-25-22_screenshot.png]]

***** ALU operation: Inputs

#+DOWNLOADED: screenshot @ 2020-12-30 17:14:33
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_17-14-33_screenshot.png]]

 CPU designer has to take these six green bits or more accurately copies of these bits and root them all the way to the control bits of the ALU

***** ALU operation: Outputs

#+DOWNLOADED: screenshot @ 2020-12-30 17:17:29
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_17-17-29_screenshot.png]]

**** Control

#+DOWNLOADED: screenshot @ 2020-12-30 17:19:50
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_17-19-50_screenshot.png]]

***** possible outside view of the hack computer

#+DOWNLOADED: screenshot @ 2020-12-30 17:23:14
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_17-23-14_screenshot.png]]

***** abstraction

#+DOWNLOADED: screenshot @ 2020-12-30 17:26:48
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_17-26-48_screenshot.png]]

***** implementation

#+DOWNLOADED: screenshot @ 2020-12-30 17:28:43
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_17-28-43_screenshot.png]]

And if you look at the diagram, you can see that this load is actually the load bit of the program counter. So ~if load ends up being one, yes, we want to jump.~ So we PC equals A. PC equals. The current, value on the register which contains the address to which we want to jump. Otherwise we do PC++.

At the end of all this operation and all the dust clears what we'll get is that the ~PC always emits the address of the next instruction that has to be fetched and executed~.

** Overall Hack Architecture

#+DOWNLOADED: screenshot @ 2020-12-30 17:32:52
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_17-32-52_screenshot.png]]

*** Hack CPU operation

#+DOWNLOADED: screenshot @ 2020-12-30 17:35:39
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_17-35-39_screenshot.png]]

RHS: right hand side
LHS: left hand side

#+DOWNLOADED: screenshot @ 2020-12-30 17:42:52
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_17-42-52_screenshot.png]]

*** Memory

#+DOWNLOADED: screenshot @ 2020-12-30 17:44:25
#+ATTR_ORG: :width 500
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_17-44-25_screenshot.png]]

**** Implementation

#+DOWNLOADED: screenshot @ 2020-12-30 17:45:20
#+ATTR_ORG: :width 500
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_17-45-20_screenshot.png]]

**** RAM

#+DOWNLOADED: screenshot @ 2020-12-30 17:46:20
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_17-46-20_screenshot.png]]

**** Screen

#+DOWNLOADED: screenshot @ 2020-12-30 17:47:20
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_17-47-20_screenshot.png]]


#+DOWNLOADED: screenshot @ 2020-12-30 17:47:43
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_17-47-43_screenshot.png]]

**** Keyboard

#+DOWNLOADED: screenshot @ 2020-12-30 17:49:13
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_17-49-13_screenshot.png]]

#+DOWNLOADED: screenshot @ 2020-12-30 17:49:24
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_17-49-24_screenshot.png]]

**** Instruction memory (ROM)

#+DOWNLOADED: screenshot @ 2020-12-30 23:06:29
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_23-06-29_screenshot.png]]

**** Handling screen output in the hack platform

#+DOWNLOADED: screenshot @ 2020-12-30 23:08:17
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_23-08-17_screenshot.png]]
Another control of interest is this one, which shows you the current value of the so-called ~program counter~. The program counter is a register that contains the address of the instruction that will be executed next in the program, which is currently loaded into the instruction memory.

*** ROM interface

#+DOWNLOADED: screenshot @ 2020-12-30 23:14:25
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_23-14-25_screenshot.png]]

*** Hack computer implementation


#+DOWNLOADED: screenshot @ 2020-12-30 23:24:52
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_23-24-52_screenshot.png]]

** Project#5 overview
*** Hardware organization: a hierarchy of chip parts

#+DOWNLOADED: screenshot @ 2020-12-30 23:32:51
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_23-32-51_screenshot.png]]

*** CPU implementation

#+DOWNLOADED: screenshot @ 2020-12-30 23:34:43
#+ATTR_ORG: :width 700
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_23-34-43_screenshot.png]]

And your job as, the designer of this chip, is to ~unpack these control bits and send them, or route them, using HDL, to their correct destinations~ in the various chip parts that make the overall architecture.

#+DOWNLOADED: screenshot @ 2020-12-30 23:37:13
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_23-37-13_screenshot.png]]

*** Memory implementation
**** abstraction

#+DOWNLOADED: screenshot @ 2020-12-30 23:38:41
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_23-38-41_screenshot.png]]
*** ROM32K
provided

#+DOWNLOADED: screenshot @ 2020-12-30 23:41:09
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_23-41-09_screenshot.png]]

*** Computer implementation

#+DOWNLOADED: screenshot @ 2020-12-30 23:41:43
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#5_-_Computer_Architecture/2020-12-30_23-41-43_screenshot.png]]

** Perspectives
*** main architectural: Von Neumann vs Harvard

*** what does it take to connect a computer to more peripheral devices in addition to a keyboard and a screen?
real computers have many peripheral units which are the screen, the keyboard, a mouse, a microphone, a disk and so on so forth.

And also this architecture is scalable. We can add more devices as we please and the question in there is ~how can you possibly do it?~ Well just like we did with the screen and the keyboard,

we can allocate memory space to represent every one of these peripheral devices. And when we want to write something, for instance when we want to sound something on the microphone or write something to the disk, we can write into memory certain codes that are later later, will be translated into physical signals that actually operate these peripheral devices. But at some point, ~when you add several such peripheral devices, the CPU becomes extremely overloaded.~ Because the poor CPU has to not only run your program, but also manage all these peripheral devices. So the ~typical approach is to offload the CPU from all this headache and use what is known as device controllers~. So typically, when you add, for example, a disk. The disk will be equipped with device controller, which is a dedicated hardware, which knows how to manage the disk, which knows how to translate operations from what the CPU wants to do to actual movements of the disk an, and so on. And something like this happens with every particular I/O device. And for example, take the screen. In the, Hack platform, the screen is managed in a very simplistic way. When you want to turn on and off a pixel, you simply turn on and off a bit in memory. And you assume that at some point this this manipulation will be refreshed or will, will cause the screen to be refreshed. So the CPU is in charge for every thing. If you want to draw a line, the CPU has to actually write all these points all these bits into memory and, and the line will get drawn at a certain point of time.

In a real computer the screen comes equipped with a ~graphics card or some graphics accelerator~ and this is a dedicated computer that can do all sorts of things internally. So if we want to draw a line from one coordinate to another, we can simply tell the controller go ahead and do it and the controller will, you know, will do everything, which is necessary to compute which pixels have to be turned on and off and so on. So, once again, ~we can add many I/O devices as we please~. U, in principle, it will be very similar to what we did with the screen and the keyboard. But there are numerous details involved, which are specific to all these different devices.

* Module#6 - Assembler
Assembler = Assembly lang(=symbolic Hack code) to Machine code(=binary Hack code) Translator
Every computer has a binary machine language, in which instructions are written as series of 0's and 1's, and a symbolic machine language, also known as assembly language, in which instructions are expressed using human-friendly mnemonics. Both languages do exactly the same thing, and are completely equivalent. But, writing programs in assembly is far easier and safer then writing in binary. ~In order to enjoy this luxury, someone has to translate our symbolic programs into binary code that can execute as-is on the target computer~. This translation service is done by an agent called ~assembler~. The assembler can be either a person who carries out the translation manually, or a computer program that automates the process. In this module and final project in the course we learn ~how to build an assembler~. In particular, ~we'll develop the capability of translating symbolic Hack programs into binary code that can be executed as-is on the Hack platform~. Each one of you can choose to accomplish this feat in two different ways: you can either implement an assembler using a high-level language, or you can simulate the assembler's operation using paper and pencil. In both cases we give detailed guidelines about how to carry out your work.

Key concepts: Binary and symbolic machine languages, parsing, symbol tables, code generation, cross assembler, assembler implementation.

** Assembly language and Assemblers

#+DOWNLOADED: screenshot @ 2021-01-01 21:31:59
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-01_21-31-59_screenshot.png]]

*** Basic Assembler logic

#+DOWNLOADED: screenshot @ 2021-01-01 21:32:41
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-01_21-32-41_screenshot.png]]


*** Read the next Assembly language command
#+DOWNLOADED: screenshot @ 2021-01-01 21:34:16
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-01_21-34-16_screenshot.png]]
*** Break it into the different fields it is composed of
#+DOWNLOADED: screenshot @ 2021-01-01 21:34:26
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-01_21-34-26_screenshot.png]]

*** Lookup the binary code for each field

#+DOWNLOADED: screenshot @ 2021-01-01 21:36:05
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-01_21-36-05_screenshot.png]]

*** Combine these codes into a single machine language command

#+DOWNLOADED: screenshot @ 2021-01-01 21:37:13
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-01_21-37-13_screenshot.png]]

*** Output this machine language command

#+DOWNLOADED: screenshot @ 2021-01-01 21:37:52
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-01_21-37-52_screenshot.png]]

*** Symbols

#+DOWNLOADED: screenshot @ 2021-01-01 21:39:17
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-01_21-39-17_screenshot.png]]

*** Allocation of variables

#+DOWNLOADED: screenshot @ 2021-01-01 21:41:14
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-01_21-41-14_screenshot.png]]

#+DOWNLOADED: screenshot @ 2021-01-01 21:41:42
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-01_21-41-42_screenshot.png]]

*** Labels

#+DOWNLOADED: screenshot @ 2021-01-01 21:43:51
#+ATTR_ORG: :width 400
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-01_21-43-51_screenshot.png]]

*** Forward references
when label is called before the label is defined

#+DOWNLOADED: screenshot @ 2021-01-01 21:46:03
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-01_21-46-03_screenshot.png]]

** The Hack assembly language: a Translator's perspective
*** The translator's challenge

#+DOWNLOADED: screenshot @ 2021-01-01 21:48:45
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-01_21-48-45_screenshot.png]]

*** Hack language specification: A-instruction
*** Hack language specification: C-instruction
*** Hack language specification: symbols

#+DOWNLOADED: screenshot @ 2021-01-01 21:53:09
#+ATTR_ORG: :width 400
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-01_21-53-09_screenshot.png]]

*** Hack language: a translator's perspective

#+DOWNLOADED: screenshot @ 2021-01-01 21:53:59
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-01_21-53-59_screenshot.png]]

*** Symbols


#+DOWNLOADED: screenshot @ 2021-01-01 21:55:05
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-01_21-55-05_screenshot.png]]

*** Handling programs without symbols

#+DOWNLOADED: screenshot @ 2021-01-01 21:55:33
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-01_21-55-33_screenshot.png]]

*** The plan ahead

#+DOWNLOADED: screenshot @ 2021-01-01 22:13:10
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-01_22-13-10_screenshot.png]]

** The assembly process - handling instructions
*** Translating A-instructions

#+DOWNLOADED: screenshot @ 2021-01-01 22:16:40
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-01_22-16-40_screenshot.png]]

*** Translating C-instructions

#+DOWNLOADED: screenshot @ 2021-01-01 22:20:56
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-01_22-20-56_screenshot.png]]

#+DOWNLOADED: screenshot @ 2021-01-01 22:21:07
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-01_22-21-07_screenshot.png]]

#+DOWNLOADED: screenshot @ 2021-01-01 22:22:10
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-01_22-22-10_screenshot.png]]

*** The overall assembly logic

#+DOWNLOADED: screenshot @ 2021-01-01 22:27:14
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-01_22-27-14_screenshot.png]]

#+DOWNLOADED: screenshot @ 2021-01-01 22:28:05
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-01_22-28-05_screenshot.png]]

** The assembly process - handling symbols

#+DOWNLOADED: screenshot @ 2021-01-01 22:29:04
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-01_22-29-04_screenshot.png]]

*** Handling symbols

#+DOWNLOADED: screenshot @ 2021-01-01 22:30:03
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-01_22-30-03_screenshot.png]]

*** Handling pre-defined symbols

#+DOWNLOADED: screenshot @ 2021-01-01 22:31:28
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-01_22-31-28_screenshot.png]]

*** Handling symbols that denote labels
#+DOWNLOADED: screenshot @ 2021-01-01 22:34:46
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-01_22-34-46_screenshot.png]]

*** Handling symbols that denote variables


#+DOWNLOADED: screenshot @ 2021-01-01 22:36:39
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-01_22-36-39_screenshot.png]]

*** symbol table
#+DOWNLOADED: screenshot @ 2021-01-01 22:48:38
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-01_22-48-38_screenshot.png]]

*** The assembly process

#+DOWNLOADED: screenshot @ 2021-01-01 22:50:07
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-01_22-50-07_screenshot.png]]
*** quiz
#+DOWNLOADED: screenshot @ 2021-01-01 22:53:34
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-01_22-53-34_screenshot.png]]
** Developing a hack assembler: proposed software architecture
*** reading and parsing commands

#+DOWNLOADED: screenshot @ 2021-01-01 22:57:41
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-01_22-57-41_screenshot.png]]

*** Recap: parsing + translating

#+DOWNLOADED: screenshot @ 2021-01-01 22:58:19
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-01_22-58-19_screenshot.png]]

*** The symbol table

#+DOWNLOADED: screenshot @ 2021-01-01 22:59:14
#+ATTR_ORG: :width 400
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-01_22-59-14_screenshot.png]]

#+DOWNLOADED: screenshot @ 2021-01-01 22:59:49
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-01_22-59-49_screenshot.png]]

**** adding symbols

#+DOWNLOADED: screenshot @ 2021-01-01 23:00:30
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-01_23-00-30_screenshot.png]]

*** overall logic

#+DOWNLOADED: screenshot @ 2021-01-01 23:01:37
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-01_23-01-37_screenshot.png]]

** Project#6 overview
*** developing a Hack assembler

#+DOWNLOADED: screenshot @ 2021-01-02 05:15:22
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in

[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-02_05-15-22_screenshot.png]]

*** proposed design

#+DOWNLOADED: screenshot @ 2021-01-02 05:16:53
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-02_05-16-53_screenshot.png]]

*** proposed implementation

#+DOWNLOADED: screenshot @ 2021-01-02 05:18:28
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-02_05-18-28_screenshot.png]]

*** Test Program: Add

#+DOWNLOADED: screenshot @ 2021-01-02 05:19:28
#+ATTR_ORG: :width 300
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-02_05-19-28_screenshot.png]]

*** Test Program: Max

#+DOWNLOADED: screenshot @ 2021-01-02 05:20:30
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-02_05-20-30_screenshot.png]]

*** Test Program: Rectangle

#+DOWNLOADED: screenshot @ 2021-01-02 05:21:09
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-02_05-21-09_screenshot.png]]

*** Test Program: Pong

#+DOWNLOADED: screenshot @ 2021-01-02 05:26:29
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-02_05-26-29_screenshot.png]]

Jack(high-level lang) -> hack binary(from Hack assembler)

#+DOWNLOADED: screenshot @ 2021-01-02 05:31:21
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-02_05-31-21_screenshot.png]]

*** Testing options

#+DOWNLOADED: screenshot @ 2021-01-02 05:33:53
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-02_05-33-53_screenshot.png]]


#+DOWNLOADED: screenshot @ 2021-01-02 05:36:25
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-02_05-36-25_screenshot.png]]

** perspectives
*** Can you possibly improve the symbolic Hack language without changing the binary code or the machine language which is underlying the symbolic level?

macro assembler
  from D=M[100] to { @100, D=M }

macro commands
  from JUMP LOOP to {@LOOP, JMP}

#+DOWNLOADED: screenshot @ 2021-01-02 05:44:23
#+ATTR_ORG: :width 300
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#6_-_Assembler/2021-01-02_05-44-23_screenshot.png]]

*** historically what happened when the first computers were designed? When you didn't have this this tremendous luxury, how was the first assembler actually written?

* course2 overview
** how do you bridge the gap between the abstract thoughts of the high level programmer and the barebone hardware that can do nothing more than process zeros and ones?
bridging this gap is what Nand to Tetris is all about

#+DOWNLOADED: screenshot @ 2021-01-03 09:20:42
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/course_overview/2021-01-03_09-20-42_screenshot.png]]

#+DOWNLOADED: screenshot @ 2021-01-03 09:31:52
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/course_overview/2021-01-03_09-31-52_screenshot.png]]
you will become a significantly more sophisticated, enlightened, and confident software developer. Because, you see, right now, I assume that you may have some very good high-level programming skills.
~But you have all sorts of doubts, and some uneasy feelings about how the compiler works, what exactly is the virtual machine, how my program interacts with the operating system, and how all this gestalt works together.~

Well, ~Nand to Tetris sheds light on all these questions,. And as you'll get this knowledge, once again, you become a much more sophisticated developer.~ In addition, you will be exposed to numerous, or I should say, the most important ideas and techniques in applied computer science. And finally, you will become a richer person. Not necessarily financially richer, although I think that this course will certainly contribute to your career prospects. You will become richer intellectually, because, through this course, you will connect to the soul of the machine. You will connect to the soul of the most important machine that mankind has built, at least in modern times. ~And connecting to the soul of this machine is what Nand to Tetris is all about~.
** The big picture

#+DOWNLOADED: screenshot @ 2021-01-03 09:48:54
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/course_overview/2021-01-03_09-48-54_screenshot.png]]

* Module#7- Virtual Machine 1: Stack arithmetic
In some modern languages, most notably Java, the high-level code is not translated directly into machine language. Rather, Java compilers translate the high-level source code into code written in an intermediate language, designed to operate on some abstract processing layer known as a virtual machine.

In this module we begin building a ~stack-based virtual machine~. After presenting the virtual machine architecture and its VM language (which is similar to Java's bytecode), we develop a basic VM translator (similar to Java's JVM), designed to translate VM programs into the Hack machine language. In the next module we'll extend this basic translator into a full-scale VM implementation. This implementation, in turn, will serve as the backend module of the two-tier compiler that we'll develop later in the course.

~Key concepts~: two-tier compilation (overview), virtualization, virtual machines, VM abstraction, stack processing, pointers, VM implementation, VM translators.

Relevant (and optional) reading: chapter 7 of The Elements of Computing Systems, by Nisan and Schocken, MIT Press.

** The road ahead

#+DOWNLOADED: screenshot @ 2021-01-03 10:17:05
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-03_10-17-05_screenshot.png]]


#+DOWNLOADED: screenshot @ 2021-01-03 10:17:22
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-03_10-17-22_screenshot.png]]

And so we write this program, we put it into the hack computer somehow. ~We click something and boom, the screen that displays the words Hello World. Well, in most courses at this point, students continue to develop some more interesting programs.~ But in Nand to Tetris, we ~stop right here and ask ourselves a whole set of interesting questions about what happens below the surface~, so to speak. First of all, take a look at this whole notion of program execution, which is nothing short of magic. Because ~after all the program is just a bunch of dead characters that I wrote on a piece of paper or using some text editor,~ it's completely static. And all of a sudden, I can take this program and somehow transform it into a set of low-level instructions that cause the computer to actually do something. This is quite fascinating and we take it for granted.

And how did the computer know how to display the words or the images hello world on the screen. How did it know how to display H on the screen and excuse me, how did it know to display a single pixel on the screen. All these are very interesting questions that we usually don't bother to think about.

#+DOWNLOADED: screenshot @ 2021-01-03 10:18:36
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-03_10-18-36_screenshot.png]]

Q. Now some of you might say well, I don't understand, Shimone just told me that ~in order to be an application programmer, I don't have to worry about these things. So why do I have to worry about these things?~

A. Well, the answer is that indeed you can write a very nice high-level programs without understanding compilers and operating system internals. And yet, if you do so, ~you will be stuck in a certain limited and constrained level of competence.~ However, if you will take the time to indulge yourself in understanding how these wonderful software layers work. You will become a far more competent and sophisticated software developer. ~And not only that, you will also become a much richer person intellectually speaking.~

~Because in order to develop a VM, a compiler in operating system,~ you have to ~learn how to use some incredibly beautiful algorithms. Data structures, programming techniques and all sorts of things that will advance you tremendously.~ Not necessarily in understanding the lower level details, but in general, as a software developer. And as a thinker and also of course, as an applied computer scientist. All right, so with that in mind, here's the big picture, these are the major stations in our journey. And the last station is a high-level language and I would like to devote this unit to discussing the end of our journey. What will happen at the end? Well, at the end, we'll be able to write programs in the Jack language, which is quite similar to Java in many respects. And I would like to give you an example of how these programs will look like.

#+DOWNLOADED: screenshot @ 2021-01-03 10:21:05
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-03_10-21-05_screenshot.png]]

*** High-level programming

#+DOWNLOADED: screenshot @ 2021-01-03 10:23:15
#+ATTR_ORG: :width 700
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-03_10-23-15_screenshot.png]]

#+DOWNLOADED: screenshot @ 2021-01-03 10:31:26
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-03_10-31-26_screenshot.png]]

#+DOWNLOADED: screenshot @ 2021-01-03 10:31:36
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-03_10-31-36_screenshot.png]]

*** From high-level to low-level

#+DOWNLOADED: screenshot @ 2021-01-03 10:34:00
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-03_10-34-00_screenshot.png]]

**** in java
#+DOWNLOADED: screenshot @ 2021-01-03 10:35:01
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-03_10-35-01_screenshot.png]]

*** Course plan

#+DOWNLOADED: screenshot @ 2021-01-03 10:38:34
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-03_10-38-34_screenshot.png]]

*** Before we take off...

#+DOWNLOADED: screenshot @ 2021-01-03 10:41:05
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-03_10-41-05_screenshot.png]]

** Program compilation preview

#+DOWNLOADED: screenshot @ 2021-01-04 18:11:10
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-04_18-11-10_screenshot.png]]

best example of this approach : Java

*** Tier 2: virtual machine implementation
keyword: ~decoupling~
#+DOWNLOADED: screenshot @ 2021-01-04 18:12:10
#+ATTR_ORG: :width 450
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-04_18-12-10_screenshot.png]]

*** Jack compilation

#+DOWNLOADED: screenshot @ 2021-01-04 18:15:22
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-04_18-15-22_screenshot.png]]

#+DOWNLOADED: screenshot @ 2021-01-04 18:16:03
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-04_18-16-03_screenshot.png]]

** VM abstraction: the Stack
*** The big picture

#+DOWNLOADED: screenshot @ 2021-01-04 18:20:08
#+ATTR_ORG: :width 300
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-04_18-20-08_screenshot.png]]

Well, we have to strike a ~balance~ between two conflicting objectives. On the one hand, ~we want the VM language to be sufficiently high so that the distance~, so to speak, between the high level and the VM level will be relatively low. And therefore, ~the translation challenge will be relatively manageable~, and the resulting VM compiler will be a relatively simple and elegant programs. On the other hand, ~we want the VM code and the VM language to be sufficiently low~, so that the distance that we have to cover between it and the final target language, the low level language. Will also be ~manageable and conveniently small, so that the VM translator or the VM implementation will also be a relatively simple and elegant program.~ So we have to ~find the right balance~ and years of research and practice in computer science have indicated that ~one architecture that hits a very good balance between these two objectives, is something called stack machine~. And the stack machine is an abstraction that consists of an architecture, a stack, and a set of operations which we can apply to this architecture. And this is a good summary of what we're going to do from now on, we're going to describe this architecture and this set of commands. So let's begin with a stack.
*** Stack

#+DOWNLOADED: screenshot @ 2021-01-04 18:29:33
#+ATTR_ORG: :width 400
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-04_18-29-33_screenshot.png]]

#+DOWNLOADED: screenshot @ 2021-01-04 18:31:19
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-04_18-31-19_screenshot.png]]
*** Stack arithmetic

#+DOWNLOADED: screenshot @ 2021-01-04 18:32:49
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-04_18-32-49_screenshot.png]]
*** Stack arithmetic (big picture)

#+DOWNLOADED: screenshot @ 2021-01-04 18:35:06
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-04_18-35-06_screenshot.png]]
*** arithmetic commands

#+DOWNLOADED: screenshot @ 2021-01-04 18:39:59
#+ATTR_ORG: :width 700
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-04_18-39-59_screenshot.png]]
*** logical commands

#+DOWNLOADED: screenshot @ 2021-01-04 18:41:41
#+ATTR_ORG: :width 750
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-04_18-41-41_screenshot.png]]
*** arithmetic commands

#+DOWNLOADED: screenshot @ 2021-01-04 18:42:33
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-04_18-42-33_screenshot.png]]

** VM abstraction: memory segments
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-04_18-46-25_screenshot.png]]

So we ~need some mechanism to record the different roles of different variables in one's program.~ And we do this by introducing the ~notion of memory segments~, which is part of our VM obstruction. So our stack machine is going to be equipped, ~not with a single memory segment as we had so far. But rather with several memory segments with names like argument, local, static and a few more~ as you'll see later on. Once we have these segments in place, the ~compiler can map the variables of the high level on these segments~. And in this particular example, we'll get this particular mapping.

And once we have this mapping in place, we can use it in order to generate code. ~So instead of saying push s1, we're going to say push static 0~. And instead of pushing y, which is argument number 1, we're going to say push argument 1. And instead of saying add, well add is add, there's nothing to add. But instead of saying pop c, we are going to say pop local 2. So we see that once ~we use the segments in this way we're going to be able to preserve the role semantics of these variables also in the VM obstruction~. But something interesting has happened, ~we lost the variable names in the process~.
And indeed, the ~VM obstruction does not recognize symbolic variable names.~ ~All the variables are replaced by references to memory segments as we see here~. And this is not something which is unique to our VM. Our VM, by the way, is modeled after the JVM, the Java virtual machine, in broad terms, and the JVM also does not have symbolic variables. ~It only has references to symbolic memory segments.~ So as you see, we have extended the story and instead of interacting with the single memory stream, we now interact with several different memory segments. To which we also add a segment that we call constant, which is truly a virtual segment, because it contains just the numbers as 0, 1, 2 and so on and so forth. And once you have these segments in place, well the commands that you are going to use, the push and pop are going to take as arguments the name of the segment that you want to operate on and the index in that segment.

*** Memory segments

#+DOWNLOADED: screenshot @ 2021-01-04 18:50:47
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-04_18-50-47_screenshot.png]]
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-04_19-06-02_screenshot.png]]

*** Quiz#1
#+ATTR_ORG: :width 300
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-04_19-04-53_screenshot.png]]

#+begin_src virtual_machine
push constant 0
pop local 0
push constant 15
pop local 1
push local 1
push argument 1
gt
pop local 2
push local 0
push argument 0
add
pop local 0
push local 1
push local 1
push constant 1
sub
add
pop local 1
#+end_src

Q: What will be the value of local 1?
A: 29

First, 15 is popped to local 1. Then 15+15-1 was calculated and popped to local 1.
// constant 0 is real 0, and constant 15 is real 15
// for example, if you do "push constant 15", you are pushing 15 to the memory
// "pop local 2": pop from memory and put it in local 2
// "sub": pop two last numbers from memory and operate subtraction of two numbers and push that number(result) to the memory


*** Quiz#2

#+DOWNLOADED: screenshot @ 2021-01-04 19:07:19
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-04_19-07-19_screenshot.png]]

#+begin_src virtual_machine
push argument 1
pop static 2
#+end_src

In order to move the value of argument 1 to static 2, we ~must go through the stack~. That's the only way to do it in a stack machine, so ~we push argument 1 onto the stack~. And then ~we pop the topmost value~, the value that we have just added onto static 2. ~And because these two commands kind of cancel each other stackwise, we see that the stack remained the same~. A lot of drama happened, right? We added something, we took something away from the stack. But at the ~end of the game, the stack is intact.~ And we ~managed to move something from one segment to the other.~ And that's the ~only way~ to move values from one segment to another in our VM abstruction.

** VM implementation: the stack
*** Pointer manipulation

#+DOWNLOADED: screenshot @ 2021-01-04 19:17:26
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-04_19-17-26_screenshot.png]]

1. p is the address number
2. if you do @p, A become p (A = p, A stands for address register) and M(M stands for memory register, M holds the content of the value that A register has) become the address value.(M value changes along with A)
3. after, A = M, we are changing address value to M. (move to different address) so along with it, M has to change together which is from the right side table, 23(address 257 has value 23)
4. and you put that memory value, 23 into D(data register)

#+DOWNLOADED: screenshot @ 2021-01-04 19:23:44
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-04_19-23-44_screenshot.png]]

D = 19

#+DOWNLOADED: screenshot @ 2021-01-04 19:27:22
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-04_19-27-22_screenshot.png]]

*** stack machine
#+DOWNLOADED: screenshot @ 2021-01-04 20:05:51
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-04_20-05-51_screenshot.png]]

*** VM translator perspective

#+DOWNLOADED: screenshot @ 2021-01-04 20:10:47
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-04_20-10-47_screenshot.png]]

*SP = i, SP++ is just the logic of the Hack assembly, see above picture

** VM implementation: Memory segments
*** implementing local
Q: if base address of the local segment is 256, what if they meet?
what if there are lots of variables you have to store, and what if they meet together?
#+DOWNLOADED: screenshot @ 2021-01-04 21:28:15
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-04_21-28-15_screenshot.png]]

#+DOWNLOADED: screenshot @ 2021-01-04 21:37:51
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-04_21-37-51_screenshot.png]]
pop : pop the last number(5) from stack
local 2: store the number you just popped in local stack
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-04_21-40-58_screenshot.png]]
*** implementing local, argument, this, that
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-04_21-45-14_screenshot.png]]

Well, think about a typical method in let's say in Java which is operating in run time. Well, this method typically has local variables, it has argument variables, typically it processes some current object which is also a bundle of so-called member variables, I think. And also the method may well process some array that also has entries, which are data values. So ~when we translate this logic into the world of the virtual machine, we have to preserve all this semantics.~ Well, we do this with the local and argument memory segments, as well as with ~two other segments that we call this and that~. This segment stores the member variables or the values of the fields of the current object, and the that segment stores the values of the array that the current method may be processing. So basically, ~we are using these four segments in order to capture these semantics also at the VM level.~ So how do we implement these four memory segments? Well, first of all let us remember that abstractly we use them exactly the same way. ~We do push and pop, segment name, index and that's it,~ we don't need anything beyond that. So they are accessed in a uniform fashion.


#+DOWNLOADED: screenshot @ 2021-01-04 21:49:20
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-04_21-49-20_screenshot.png]]
*** Memory segment: constant

#+DOWNLOADED: screenshot @ 2021-01-04 21:53:02
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-04_21-53-02_screenshot.png]]

#+DOWNLOADED: screenshot @ 2021-01-04 21:54:08
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-04_21-54-08_screenshot.png]]

*** Memory segment: static

#+DOWNLOADED: screenshot @ 2021-01-04 21:55:03
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-04_21-55-03_screenshot.png]]

*** Implementing static


#+DOWNLOADED: screenshot @ 2021-01-04 21:58:04
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-04_21-58-04_screenshot.png]]

*** Memory segment: temp

#+DOWNLOADED: screenshot @ 2021-01-04 22:02:33
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-04_22-02-33_screenshot.png]]

*** Implementing temp

#+DOWNLOADED: screenshot @ 2021-01-04 22:03:18
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-04_22-03-18_screenshot.png]]

*** Memory segment: pointer
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-04_22-04-01_screenshot.png]]

*** Implementing pointer
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-04_22-33-54_screenshot.png]]

admit that this segment and the way we use it and realize it may sound somewhat peculiar and strange. But you shouldn't worry about it because it will make perfect sense once we talk about code generation when we set out to write eject compiler. For now, let us just strive to create this
*** Quiz

#+DOWNLOADED: screenshot @ 2021-01-04 22:37:41
#+ATTR_ORG: :width 400
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-04_22-37-41_screenshot.png]]

*** VM language

#+DOWNLOADED: screenshot @ 2021-01-04 22:40:30
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-04_22-40-30_screenshot.png]]

** The VM Emulator
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-05_16-50-08_screenshot.png]]
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-05_16-52-59_screenshot.png]]

*** example
#+DOWNLOADED: screenshot @ 2021-01-05 16:54:20
#+ATTR_ORG: :width 700
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-05_16-54-20_screenshot.png]]

*** test script
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-05_16-57-59_screenshot.png]]

*** Some missing elements
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-05_16-59-59_screenshot.png]]
** VM Implementation on the Hack platform
 how to map the VM translator, or the virtual machine, on the host RAM and the host computer.
*** VM translator(VM Assembly translator)

#+DOWNLOADED: screenshot @ 2021-01-05 18:27:59
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-05_18-27-59_screenshot.png]]

*** Source: VM language

#+DOWNLOADED: screenshot @ 2021-01-05 18:28:27
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-05_18-28-27_screenshot.png]]

*** Target: Symbolic Hack code
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-05_18-33-21_screenshot.png]]

*** Standard VM mapping on the Hack platform

#+DOWNLOADED: screenshot @ 2021-01-05 18:33:45
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-05_18-33-45_screenshot.png]]

Now another thing that we need to know is what is sometimes called the ~standard VM mapping on the target platform~. Now let me explain what I mean by, you know what, let me first show you the standard mapping. And then we'll discuss why we actually need it.

So basically, we have to make ~two decisions~, ~how to map the VM's data structures on the host RAM~, and also ~how to express the commands in the host language.~

Now the standard mapping gives you all sorts of information or conventions on how we propose that you achieve this mapping. Because think about it. If I tell you to implement a VM translator, basically you're free to do whatever you want. I can tell you, here's the RAM, do whatever you want with it. However, it is convenient and customary to propose a certain ~standard mapping that will ensure two things.~

~To avoid collision~:
First of all, if you agree to put the various segments in where advise to put it in the RAM, then you are going to conform to generally accepted standards that are also accepted by developers of other software tools that run on the same computer. So if everyone respects the same rules, these programs will not collide in the memory.

~Testing~:
And also, if you commit yourself to a certain mapping on the RAM, then we can write all sorts of test programs that also makes similar assumptions. And by doing this, the team that tests the software can be another team, other than that that actually developed the software. Which always is recommended in order to perform objective testing.

#+DOWNLOADED: screenshot @ 2021-01-05 18:42:36
#+ATTR_ORG: :width 700
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-05_18-42-36_screenshot.png]]


#+DOWNLOADED: screenshot @ 2021-01-05 18:44:17
#+ATTR_ORG: :width 700
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-05_18-44-17_screenshot.png]]

** VM to assembly Translator: Proposed Implementation

#+DOWNLOADED: screenshot @ 2021-01-05 19:04:42
#+ATTR_ORG: :width 700
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-05_19-04-42_screenshot.png]]

*** The VM translator: usage

#+DOWNLOADED: screenshot @ 2021-01-05 19:06:32
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-05_19-06-32_screenshot.png]]

*** Implementation

#+DOWNLOADED: screenshot @ 2021-01-05 19:08:40
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-05_19-08-40_screenshot.png]]

So we propose to develop ~three stand alone modules if you will or in the world of Java this would be called the three different classes, a Parser class, a CodeWriter class and a Main class.~ And the Main class is just a surrogate name for the class that we saw before which will be called VM Translator. So, the main class, ~the VM Translator has one input which is file name .vm. And it generates as output as filename.asm~ as we saw in the demo that they previously showed you. Now, how do this main class operate? Well, the logic of this main class is that it will have some main method that does the following. First of all, ~it constructs a parser, in order to handle the input file~, and we'll discuss this parser later on. Then ~it constructs a codewriter, to handle the generation of the code that we have to output,~ and we'll discuss this CodeWriter later as well. And then once we have this to object setup, we can march through the input file, through fileName.vm and handle each row in this file separately. For each of these rows which represents a VM command, we can parse this role or line using a Parser, using a Parser functionality.

And once ~we parse this line into it's constituent VM elements~, we can ~pass this information to the CodeWriter in order to generate the appropriate code in assembly~ that we will later put together and write to the output file.

*** Parser API

#+DOWNLOADED: screenshot @ 2021-01-05 19:18:42
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-05_19-18-42_screenshot.png]]

#+DOWNLOADED: screenshot @ 2021-01-05 19:24:28
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-05_19-24-28_screenshot.png]]

*** CodeWriter API


#+DOWNLOADED: screenshot @ 2021-01-05 19:27:44
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-05_19-27-44_screenshot.png]]

*** The big picture

#+DOWNLOADED: screenshot @ 2021-01-05 19:28:32
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-05_19-28-32_screenshot.png]]

** Project#7: Building the VM Translator, Part-1

#+DOWNLOADED: screenshot @ 2021-01-05 23:50:46
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-05_23-50-46_screenshot.png]]
*** Objective
#+DOWNLOADED: screenshot @ 2021-01-06 00:38:21
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-06_00-38-21_screenshot.png]]

#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-06_00-39-53_screenshot.png]]

*** Test

#+DOWNLOADED: screenshot @ 2021-01-06 00:40:59
#+ATTR_ORG: :width 700
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-06_00-40-59_screenshot.png]]

*** Development Plan

#+DOWNLOADED: screenshot @ 2021-01-06 00:42:41
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-06_00-42-41_screenshot.png]]

#+DOWNLOADED: screenshot @ 2021-01-06 00:44:50
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-06_00-44-50_screenshot.png]]

*** Tools and resources

#+DOWNLOADED: screenshot @ 2021-01-06 00:45:57
#+ATTR_ORG: :width 700
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-06_00-45-57_screenshot.png]]

*** Some testing challenges

#+DOWNLOADED: screenshot @ 2021-01-23 20:30:41
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-23_20-30-41_screenshot.png]]

1. write a program that translate VM(e.g. BasicTest.vm) file to asm(e.g. BasicTest.asm) file // I can use any programming language for that.
2. feed that .asm file to CPU Emulator with .tst file and check if it says comparison was successful.

#+DOWNLOADED: screenshot @ 2021-01-24 19:48:39
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-24_19-48-39_screenshot.png]]

#+DOWNLOADED: screenshot @ 2021-01-24 19:49:00
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#7-_virtual_machine_overview/2021-01-24_19-49-00_screenshot.png]]
** perspectives
*** how close is our VM to Java's JVM?
Java's virtual machine is also based on an intermediate language which in the Java case is called bytecode. And obviously there are quite a few technical differences between our VM language and this bytecode.

For example, our language recognizes only 1 day to type a 16 bit integer and yet Java's bytecode commands are designed to manipulate integers, floating point, double precision, and also some other additional data types. So in that respect, ~it's much richer than our own VM language.~ Also, Java's bytecode offers also some high level obstructions that our VM language lacks like ~multiplication and division as well as low level commands like bit wise operations and so on.~ So it has more expressive power. And yet in ~it's most essential elements these two languages are quite similar. Both languages are stack based, both use their push and pop and both access their memory using virtual memory segments instead of symbolic variables.~

Now, it may be interesting to track the historical motivation for founding the Java language. Only two tier complication model. One that uses a virtual machine as an intermediate layer.

Well, you see ~Java was developed in the mid 1990s~ by people who worked in a mighty company called ~Sun Micro Systems~.

And I kind of chuckle when I mention Sun because when I was at your average age, Sun was a revered company. And now, it's no more.
Well, actually, it is buried somewhere in the bowls of Oracle.
Who acquired Sun, very wisely I think, back in 2010. But going back to the mid 90s when the story of Java begins, the world of business and office applications was completely dominated by a company called Microsoft.

And Sun, which was the a rival of Microsoft, wanted to distinguish itself by dominating everything else. And in order to achieve this dominance, ~Sun decided to create a new programming language in which one could write programs that will travel through the Internet and execute on any possible mobile device and digital appliance out there~.

Whether it is a PC, a digital television, a refrigerator, a washing machine, a sprinkler system, a toaster, whatever. Some wanted to connect everything and it wanted everything to be connected to some.

And so they decided to base this vision on a universal VM architecture that could be implemented with relative ease on any given harder platform and digital device out there.

Now, if the whole thing sounds to you quite similar to P-code, then you're absolutely right. It was the same problem, cross platform compatibility, and the same VM solution approach only on a much bigger, world class, megalomanic scale.

So the basic idea, which still prevails is that a Java compiler first generates bytecode and this bytecode can be deployed through the Internet to any connected device

and once it reaches it's destination there will be a client site JVN or a VM implementation that executes the code on the client device. How? By translating the VM code into the devices machine language just like we did with our own VM translator.

Now, going back to the mid 90s, ~it turns out that historically, these lofty ideas of Sun were ahead of their time. And the beginning of Java was somewhat sluggish. But then, something completely unexpected happened. The cell phone happened. And before you could say iPhone, or Samsung, the world was flooded by numerous cellphone models using dozens of different processors, chipsets and operating systems. So all of a sudden the pre-sync Java Vision of running the same software on many different devices became extremely relevant~

And it happened in a new setting, cell phones. Something that neither Sun, nor Microsoft, nor Intel could possibly imagine.
So with the delay of about ten years, Java all of a sudden became the right thing in the right time.
And so, there's no wonder that it also quickly became the language of choice for developing apps for mobile devices. And up until now, I think that Java is still the most popular programming language in the Android space.
So all this goes to show, that if you come up with an elegant and clean idea, in our case, an abstract, hardware-independent virtual machine, then someone, at some point, will pick up this idea. Either you or someone else and turn it into an extremely useful and practical technology.
Now, nothing can stop a good idea, it has a life of its own. Now, I would like to conclude this module with a note about efficiency.
Throughout this module our contract called for developing a VM Translator, without requiring that the generated machine code will be either compact or efficient.
Obviously, this is a very serious oversight. Because you see, you have to realize that a Vm Translator is a mission-critical program. It's a program that, in one way or another, lies in the very core of most PCs, tablets, and cell phones out there.
~And it may be called the JVM or KVM or ART or CLR, at the end of the day it's a VM Translator.~ And therefore, ~if your VM Translator generates inefficient and lengthy code, then all the apps that run on top of it will become sluggish and users will get frustrated.~
So in reality, developers of VM Translator work very hard to generate low level code which is a tight and efficient as possible. And that's something that, up until now, in non-tertiary spot, too, we've completely ignored.
Also, I would like to point out that the stake architecture that we use so carefully in this course, is not really a necessary ingredient of a virtual machine. For example, the JVM which is installed these days on Android devices, uses another abstract architecture which is called register machine. This register machine is perhaps less elegant than the beautiful than our own stack architecture, but arguably, it generates code which is better optimized for processors of mobile devices. You see, when it comes to efficiency, developers of mission critical software layers are very opportunistic and they use anything that works better and faster. So we can go on and on with these questions and discussions and there's no one around here to tell me to shut up. So I'm going to force myself to stop and we'll meet again in the next module in which we'll continue to develop our VM obstruction and implementation and this will be module two.

* Module#8- Virtual Machine 2: Program Control
In the previous module we presented a virtual machine abstraction, and developed a basic VM translator that implements the VM language's arithmetic and memory access commands. In this module we'll complete the VM translator by ~implementing the remaining VM language's branching and function-calling commands~.

~Branching and function-calling~ are of course major elements of programming theory and practice. Therefore, we'll start the module with a general overview of their usage, abstraction and implementation. This will set the stage for the remainder of the module, in which we'll complete the specification and implementation of the VM translator.

~Key concepts~: branching, functions, function call-and-return, dynamic memory management, stack processing, pointers, standard mapping, VM implementation.

Relevant (and optional) reading: chapter 8 of The Elements of Computing Systems, by Nisan and Schocken, MIT Press.

** Program control

#+DOWNLOADED: screenshot @ 2021-01-27 20:02:01
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Stack_arithmetic/2021-01-27_20-02-01_screenshot.png]]

The beauty of this is that ~the story of implementing these functions~ is ~completely separate from~ ~the story of using them~. And I can begin using them before they even implemented because they can assume that they will provide some value.

#+DOWNLOADED: screenshot @ 2021-01-27 20:04:20
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Stack_arithmetic/2021-01-27_20-04-20_screenshot.png]]

#+DOWNLOADED: screenshot @ 2021-01-27 20:04:49
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Stack_arithmetic/2021-01-27_20-04-49_screenshot.png]]
*** Module2: Take home lessons

#+DOWNLOADED: screenshot @ 2021-01-27 20:08:52
#+ATTR_ORG: :width 400
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Stack_arithmetic/2021-01-27_20-08-52_screenshot.png]]

** Branching

#+DOWNLOADED: screenshot @ 2021-01-27 20:10:30
#+ATTR_ORG: :width 700
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Stack_arithmetic/2021-01-27_20-10-30_screenshot.png]]

*** Program example

#+DOWNLOADED: screenshot @ 2021-01-27 20:30:13
#+ATTR_ORG: :width 700
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Stack_arithmetic/2021-01-27_20-30-13_screenshot.png]]

*** Conditional branching

#+DOWNLOADED: screenshot @ 2021-01-27 20:30:30
#+ATTR_ORG: :width 700
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Stack_arithmetic/2021-01-27_20-30-30_screenshot.png]]

And notice that whenever we wish to use a conditional goto command, we must
first push onto the stack a certain condition or a certain expression that
describes a condition.
And this expression will have to be evaluated before the conditional goto. Because otherwise, we will not know whether or not the condition is satisfied. So once again, the rules of the game are that you push the expression. And then when the program runs, this expression will end up being evaluated. And a certain truth value will remain on the stack. And then based on this truth value, the if-goto command will know whether or not a jump has to actually materialize.

And we see that ~in this particular example~, if you look at the high level code, the condition is n greater than y. And indeed, when you look at the generated code, we see that we have a push n, push y, gt just before the if-goto command. ~And these three VM commands taken together implement, in the VM language, the same logic as n greater than y. So once the computer will evaluate push n, push y, gt, it will get the truth value that will determine if a conditional jump should actually materialize.~
*** Recap: VM branching commands

#+DOWNLOADED: screenshot @ 2021-01-27 20:32:34
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Stack_arithmetic/2021-01-27_20-32-34_screenshot.png]]
*** Question
The execution of which of the following VM command(s) changes the state of the stack?

- goto
- if-goto
- label
- none of these commands changes the state of the stack

Executing the ~if-goto~ command involves popping the stack’s top-most value; therefore, the state of the stack changes.
** Functions: Abstraction
*** Functions in the VM language
#+DOWNLOADED: screenshot @ 2021-01-29 14:13:18
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-01-29_14-13-18_screenshot.png]]

*** Functions in the VM language: defining
#+DOWNLOADED: screenshot @ 2021-01-29 14:17:01
#+ATTR_ORG: :width 700
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-01-29_14-17-01_screenshot.png]]

*** Functions in the VM language: executing
#+DOWNLOADED: screenshot @ 2021-01-29 14:32:34
#+ATTR_ORG: :width 700
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-01-29_14-32-34_screenshot.png]]

*** Making the abstraction work: implementation
#+DOWNLOADED: screenshot @ 2021-01-29 14:36:14
#+ATTR_ORG: :width 700
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-01-29_14-36-14_screenshot.png]]

*** Quiz
In the VM language, functions are declared using the VM command "function functionName n". The integer n stands for the number of this
function’s:

- local variables

** Function call and return: Implementation preview
*** Function call and return: study plan
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-01-29_14-39-45_screenshot.png]]
*** Function execution

#+DOWNLOADED: screenshot @ 2021-01-29 14:41:20
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-01-29_14-41-20_screenshot.png]]

*** the function's state

#+DOWNLOADED: screenshot @ 2021-01-29 14:41:57
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-01-29_14-41-57_screenshot.png]]

#+DOWNLOADED: screenshot @ 2021-01-29 14:44:24
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-01-29_14-44-24_screenshot.png]]

*** Function call and return: the big picture

#+DOWNLOADED: screenshot @ 2021-01-29 14:45:35
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-01-29_14-45-35_screenshot.png]]

*** Function call and return: the details

#+DOWNLOADED: screenshot @ 2021-01-29 14:47:11
#+ATTR_ORG: :width 400
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-01-29_14-47-11_screenshot.png]]

*** Function call and return: call

#+DOWNLOADED: screenshot @ 2021-01-29 14:49:14
#+ATTR_ORG: :width 700
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-01-29_14-49-14_screenshot.png]]

*** Function call and return: function

#+DOWNLOADED: screenshot @ 2021-01-29 14:53:05
#+ATTR_ORG: :width 500
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-01-29_14-53-05_screenshot.png]]

*** Function call and return: return

#+DOWNLOADED: screenshot @ 2021-01-29 14:54:45
#+ATTR_ORG: :width 700
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-01-29_14-54-45_screenshot.png]]


#+DOWNLOADED: screenshot @ 2021-01-29 14:55:51
#+ATTR_ORG: :width 400
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-01-29_14-55-51_screenshot.png]]

*** The global stack

And it shouldn't be surprising that it's complex, because if you think about it,
~we're actually building here a little brain~.

A very primitive brain, but a brain nonetheless. Because it reminds me of,

let's say you have a robot which is designed to clean your rugs. Well that's
very nice, so the robot is roaming around, cleaning its rugs, cleaning your
rugs. And it does it because it runs a program that tells it how to clean the
rugs.

Now I assume that at some point in a future version of these robots, you will be
able to sort of sit back at your home and watch the robot does its cleaning. And
then at some point you will be able to say, hey robot, make me a cup of
tea. Then the robot will have to stop and start running another function that
turns it around and leads it to make a cup of tea. And then it will take the cup
of tea, give it back to the master. And then it will say okay, so this thing is
finished, now I have to go back to work. Yeah, there was another function of
cleaning the rugs, so I'm jumping to this function. My world is restored, I have
all my memory segments and then I can continue cleaning the rugs. So that's what
we're implementing here. We're implementing a little brain that can do several
things and not necessarily the same time. But it has this wonderful capacity to
stop what it's doing now, start doing something else. And by the way, while he
was doing the cup of tea, I could have stopped in and say, and you know what?
Before you do the cup of tea, go answer the doorbell. And so he will put this
thing on hold. He will go to answer the doorbell, and then will say, okay, where
was I? I was making a cup of tea, we'll go back to make a cup of tea. Give the
cup of tea, where am I now? Yeah, I'm supposed to go back to do the rugs. So we
have to implement here something which is very sophisticated. So there is no
wonder the implementation is not trivial.

So that's one thing that I wanted to say, and the other thing is, is that we are
now in a position to introduce this notion of what we call the global stack. And
think about it, above this stack which we are growing here there are more states
of functions that are up the climbing chain, right? Because in this example, we
talked only about the caller and the callee. But there are many other pairs of
callers and callee up the counting chain, and we have to maintain all these
states also. So we get a very large stack which we call the global stack that
contains everything. And contains all the information which we need in order to
implement and service the runtime of this program not only the current function
but the entire program. Now I can refer to some segment or some subset of this
global stack here using the term block, which I just made up. And notice what
the block contains. The block is we can call it, it's the world of the currently
running function, okay? Now what does it include? I am now the currently running
function, so my block contains, first of all, my argument segment. You see the
top we see argument 0 argument, these are my arguments. Then the block contains
some gray material that I don't deal with at all because this is some saved
information that belongs to my caller.

#+DOWNLOADED: screenshot @ 2021-01-29 15:00:45
#+ATTR_ORG: :width 700
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-01-29_15-00-45_screenshot.png]]

*** Recap
#+DOWNLOADED: screenshot @ 2021-01-29 15:04:13
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-01-29_15-04-13_screenshot.png]]

** Function call and return: Run-time simulation
*** example: factorial
#+DOWNLOADED: screenshot @ 2021-01-29 15:12:34
#+ATTR_ORG: :width 700
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-01-29_15-12-34_screenshot.png]]

*** Run-time example
#+DOWNLOADED: screenshot @ 2021-01-29 15:19:53
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-01-29_15-19-53_screenshot.png]]

*** Question
Suppose that function foo pushes two arguments and calls function bar. After bar
returns, the two argument values that were pushed before the call have
disappeared, and the stack’s topmost value is the value returned by bar. Who is
responsible for removing the argument values from the stack?

- The VM implementation

** Function call and return: Implementation
*** Function call and return

#+DOWNLOADED: screenshot @ 2021-01-29 15:34:14
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-01-29_15-34-14_screenshot.png]]

*** Contract: the calling function's view

#+DOWNLOADED: screenshot @ 2021-01-29 15:38:12
#+ATTR_ORG: :width 700
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-01-29_15-38-12_screenshot.png]]

*** Contract: the called function's view
#+DOWNLOADED: screenshot @ 2021-01-29 15:39:52
#+ATTR_ORG: :width 700
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-01-29_15-39-52_screenshot.png]]

*** The VM implementation view

#+DOWNLOADED: screenshot @ 2021-01-29 15:42:52
#+ATTR_ORG: :width 700
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-01-29_15-42-52_screenshot.png]]

*** Handling 'call'

#+DOWNLOADED: screenshot @ 2021-01-29 15:48:07
#+ATTR_ORG: :width 700
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-01-29_15-48-07_screenshot.png]]

**** Question
Consider the global stack diagram given below, and assume
the following pointer values:

SP = 305
LCL = 300
ARG = 292

#+DOWNLOADED: screenshot @ 2021-01-29 16:02:14
#+ATTR_ORG: :width 400
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-01-29_16-02-14_screenshot.png]]

Suppose that the currently running function is called foo, and foo haven't pushed / popped anything yet. How many local variables does foo have?

- 5
// SP - LCL = 305 - 300 = 5

Suppose that the currently running function is called foo. How many arguments is foo operating upon?

- 3
// LCL - ARG - 5 = 300 - 292 - 5(return address ~ saved THAT) = 3

Suppose that foo has 4 local variables, and assume that we execute the
command ~“call foo 2".~ What will be the ~value of SP~ following the execution of this call command? (meaning: just before the first real command of foo, after the ~"function foo 4"~ command)

- 314
// current SP + 5(return address ~ saved THAT) + number of local variables = 305 + 5 + 4 = 314

Suppose that foo has 4 local variables, and assume that we execute the command ~"call foo 2"~. What will be the ~value of LCL~ following the execution of this call command?

- 310
// current SP + 5(return address ~ saved THAT) = 305 + 5 = 310

Suppose that foo has 4 local variables, and assume that we execute the command
~"call foo 2".~ What will be the ~value of ARG~ following the execution of this
call command?

- 303
// current SP - number of arguments = 305 - 2 = 303

*** Handling 'function'

#+DOWNLOADED: screenshot @ 2021-01-29 16:09:24
#+ATTR_ORG: :width 700
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-01-29_16-09-24_screenshot.png]]

#+DOWNLOADED: screenshot @ 2021-01-29 16:10:42
#+ATTR_ORG: :width 700
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-01-29_16-10-42_screenshot.png]]

*** Handling 'return'
#+DOWNLOADED: screenshot @ 2021-01-29 16:16:16
#+ATTR_ORG: :width 800
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-01-29_16-16-16_screenshot.png]]

#+DOWNLOADED: screenshot @ 2021-01-29 16:18:20
#+ATTR_ORG: :width 700
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-01-29_16-18-20_screenshot.png]]

*** Question
The implementation of the VM return command starts with two commands that, taken together, store the return address in the temporary variable retAdd.  Which of the following statement(s) is correct?

This is done since, if the function has no arguments, the next command, which is  *arg = pop(), will override the return address.

last two min

*** Recap

#+DOWNLOADED: screenshot @ 2021-02-06 16:47:22
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-02-06_16-47-22_screenshot.png]]

** VM Implementation oh the Hack platform

*** The big picture: program compilation and translation

#+DOWNLOADED: screenshot @ 2021-02-06 17:46:04
#+ATTR_ORG: :width 700
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-02-06_17-46-04_screenshot.png]]

*** Booting

#+DOWNLOADED: screenshot @ 2021-02-06 17:49:08
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-02-06_17-49-08_screenshot.png]]

*** Standard mapping of the VM on the Hack platform

#+DOWNLOADED: screenshot @ 2021-02-06 17:51:02
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-02-06_17-51-02_screenshot.png]]

*** Special symbols in VM programs

#+DOWNLOADED: screenshot @ 2021-02-06 17:51:47
#+ATTR_ORG: :width 700
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-02-06_17-51-47_screenshot.png]]

** VM Translator: Proposed implementation

#+DOWNLOADED: screenshot @ 2021-02-06 17:56:21
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-02-06_17-56-21_screenshot.png]]

*** Main

#+DOWNLOADED: screenshot @ 2021-02-06 19:39:29
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-02-06_19-39-29_screenshot.png]]

*** Parser
don't need to touch from previous project

#+DOWNLOADED: screenshot @ 2021-02-06 19:40:42
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-02-06_19-40-42_screenshot.png]]

*** CodeWriter
need to extend

#+DOWNLOADED: screenshot @ 2021-02-06 19:42:01
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-02-06_19-42-01_screenshot.png]]

** Building the VM translator: part 2
your VMTranslator is required to follow this rule: Generate startup code when translating a directory. Do not generate startup code when translating a single file. Translation of a single file will be used for the basic tests.
*** The big picture
#+DOWNLOADED: screenshot @ 2021-02-06 19:44:37
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-02-06_19-44-37_screenshot.png]]

#+DOWNLOADED: screenshot @ 2021-02-06 19:44:55
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-02-06_19-44-55_screenshot.png]]

*** Testing
**** Basicloop
test if-goto
#+DOWNLOADED: screenshot @ 2021-02-06 19:48:57
#+ATTR_ORG: :width 700
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-02-06_19-48-57_screenshot.png]]

#+DOWNLOADED: screenshot @ 2021-02-06 19:50:53
#+ATTR_ORG: :width 700
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-02-06_19-50-53_screenshot.png]]

**** FibonacciSeries
test loop and label stuff

#+DOWNLOADED: screenshot @ 2021-02-06 19:52:47
#+ATTR_ORG: :width 700
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-02-06_19-52-47_screenshot.png]]

**** SimpleFunction
test function

#+DOWNLOADED: screenshot @ 2021-02-06 19:55:31
#+ATTR_ORG: :width 700
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-02-06_19-55-31_screenshot.png]]

**** FibonacciElement
more than one .vm files

need to make FibonacciElement.asm file(same as dir name)
#+DOWNLOADED: screenshot @ 2021-02-06 19:57:27
#+ATTR_ORG: :width 700
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-02-06_19-57-27_screenshot.png]]

***** Main.vm
#+DOWNLOADED: screenshot @ 2021-02-06 19:58:39
#+ATTR_ORG: :width 700
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-02-06_19-58-39_screenshot.png]]

***** Sys.vm

#+DOWNLOADED: screenshot @ 2021-02-06 20:02:07
#+ATTR_ORG: :width 700
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-02-06_20-02-07_screenshot.png]]

**** NestedCall

#+DOWNLOADED: screenshot @ 2021-02-06 20:04:44
#+ATTR_ORG: :width 700
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-02-06_20-04-44_screenshot.png]]

**** StaticTest

#+DOWNLOADED: screenshot @ 2021-02-06 20:06:42
#+ATTR_ORG: :width 700
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-02-06_20-06-42_screenshot.png]]


#+DOWNLOADED: screenshot @ 2021-02-06 20:08:41
#+ATTR_ORG: :width 700
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-02-06_20-08-41_screenshot.png]]

*** Tools and resources

#+DOWNLOADED: screenshot @ 2021-02-06 20:10:09
#+ATTR_ORG: :width 700
#+ATTR_LATEX: :width 5.5in
[[file:/home/jinho/Dropbox/org/pictures/Module#8-_Virtual_Machine_2:_Program_Control/2021-02-06_20-10-09_screenshot.png]]

** Perspective
